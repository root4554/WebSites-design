/*!
 * @pixi/core - v7.0.0-alpha.3
 * Compiled Fri, 23 Sep 2022 14:33:14 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */import{settings as m}from"@pixi/settings";export*from"@pixi/settings";import{ENV as z,ALPHA_MODES as j,SCALE_MODES as D,FORMATS as c,TYPES as x,TARGETS as Q,MSAA_QUALITY as S,MIPMAP_MODES as J,BUFFER_TYPE as O,CLEAR_MODES as W,DRAW_MODES as we,BUFFER_BITS as _t,MASK_TYPES as R,PRECISION as P,BLEND_MODES as g,GC_MODES as lr,SAMPLER_TYPES as xt,WRAP_MODES as dr}from"@pixi/constants";export*from"@pixi/constants";import{ExtensionType as _,extensions as T}from"@pixi/extensions";export*from"@pixi/extensions";import{groupD8 as C,Rectangle as w,Point as Y,Matrix as M,Transform as cr}from"@pixi/math";export*from"@pixi/math";import{Runner as L}from"@pixi/runner";export*from"@pixi/runner";import{Ticker as K}from"@pixi/ticker";export*from"@pixi/ticker";import{EventEmitter as Ae,uid as ee,isPow2 as vt,BaseTextureCache as G,TextureCache as B,determineCrossOrigin as fr,getResolutionOfUrl as Et,nextPow2 as le,getBufferType as Tt,ProgramCache as bt,removeItems as mr,hex2string as pr,hex2rgb as gr,sayHello as _r,isWebGLSupported as xr,premultiplyBlendMode as vr,log2 as yt,premultiplyTint as Er}from"@pixi/utils";import*as Tr from"@pixi/utils";m.PREFER_ENV=z.WEBGL2,m.STRICT_TEXTURE_CACHE=!1;const de=[];function Ie(s,e){if(!s)return null;let t="";if(typeof s=="string"){const r=/\.(\w{3,4})(?:$|\?|#)/i.exec(s);r&&(t=r[1].toLowerCase())}for(let r=de.length-1;r>=0;--r){const i=de[r];if(i.test&&i.test(s,t))return new i(s,e)}throw new Error("Unrecognized source type to auto-detect Resource")}class q{constructor(e=0,t=0){this._width=e,this._height=t,this.destroyed=!1,this.internal=!1,this.onResize=new L("setRealSize"),this.onUpdate=new L("update"),this.onError=new L("onError")}bind(e){this.onResize.add(e),this.onUpdate.add(e),this.onError.add(e),(this._width||this._height)&&this.onResize.emit(this._width,this._height)}unbind(e){this.onResize.remove(e),this.onUpdate.remove(e),this.onError.remove(e)}resize(e,t){(e!==this._width||t!==this._height)&&(this._width=e,this._height=t,this.onResize.emit(e,t))}get valid(){return!!this._width&&!!this._height}update(){this.destroyed||this.onUpdate.emit()}load(){return Promise.resolve(this)}get width(){return this._width}get height(){return this._height}style(e,t,r){return!1}dispose(){}destroy(){this.destroyed||(this.destroyed=!0,this.dispose(),this.onError.removeAll(),this.onError=null,this.onResize.removeAll(),this.onResize=null,this.onUpdate.removeAll(),this.onUpdate=null)}static test(e,t){return!1}}class ce extends q{constructor(e,t){const{width:r,height:i}=t||{};if(!r||!i)throw new Error("BufferResource width or height invalid");super(r,i),this.data=e}upload(e,t,r){const i=e.gl;i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.alphaMode===j.UNPACK);const n=t.realWidth,a=t.realHeight;return r.width===n&&r.height===a?i.texSubImage2D(t.target,0,0,0,n,a,t.format,r.type,this.data):(r.width=n,r.height=a,i.texImage2D(t.target,0,r.internalFormat,n,a,0,t.format,r.type,this.data)),!0}dispose(){this.data=null}static test(e){return e instanceof Float32Array||e instanceof Uint8Array||e instanceof Uint32Array}}const br={scaleMode:D.NEAREST,format:c.RGBA,alphaMode:j.NPM},te=class extends Ae{constructor(s=null,e=null){super(),e=e||{};const{alphaMode:t,mipmap:r,anisotropicLevel:i,scaleMode:n,width:a,height:o,wrapMode:h,format:u,type:l,target:d,resolution:f,resourceOptions:p}=e;s&&!(s instanceof q)&&(s=Ie(s,p),s.internal=!0),this.resolution=f||m.RESOLUTION,this.width=Math.round((a||0)*this.resolution)/this.resolution,this.height=Math.round((o||0)*this.resolution)/this.resolution,this._mipmap=r??m.MIPMAP_TEXTURES,this.anisotropicLevel=i??m.ANISOTROPIC_LEVEL,this._wrapMode=h||m.WRAP_MODE,this._scaleMode=n??m.SCALE_MODE,this.format=u||c.RGBA,this.type=l||x.UNSIGNED_BYTE,this.target=d||Q.TEXTURE_2D,this.alphaMode=t??j.UNPACK,this.uid=ee(),this.touched=0,this.isPowerOfTwo=!1,this._refreshPOT(),this._glTextures={},this.dirtyId=0,this.dirtyStyleId=0,this.cacheId=null,this.valid=a>0&&o>0,this.textureCacheIds=[],this.destroyed=!1,this.resource=null,this._batchEnabled=0,this._batchLocation=0,this.parentTextureArray=null,this.setResource(s)}get realWidth(){return Math.round(this.width*this.resolution)}get realHeight(){return Math.round(this.height*this.resolution)}get mipmap(){return this._mipmap}set mipmap(s){this._mipmap!==s&&(this._mipmap=s,this.dirtyStyleId++)}get scaleMode(){return this._scaleMode}set scaleMode(s){this._scaleMode!==s&&(this._scaleMode=s,this.dirtyStyleId++)}get wrapMode(){return this._wrapMode}set wrapMode(s){this._wrapMode!==s&&(this._wrapMode=s,this.dirtyStyleId++)}setStyle(s,e){let t;return s!==void 0&&s!==this.scaleMode&&(this.scaleMode=s,t=!0),e!==void 0&&e!==this.mipmap&&(this.mipmap=e,t=!0),t&&this.dirtyStyleId++,this}setSize(s,e,t){return t=t||this.resolution,this.setRealSize(s*t,e*t,t)}setRealSize(s,e,t){return this.resolution=t||this.resolution,this.width=Math.round(s)/this.resolution,this.height=Math.round(e)/this.resolution,this._refreshPOT(),this.update(),this}_refreshPOT(){this.isPowerOfTwo=vt(this.realWidth)&&vt(this.realHeight)}setResolution(s){const e=this.resolution;return e===s?this:(this.resolution=s,this.valid&&(this.width=Math.round(this.width*e)/s,this.height=Math.round(this.height*e)/s,this.emit("update",this)),this._refreshPOT(),this)}setResource(s){if(this.resource===s)return this;if(this.resource)throw new Error("Resource can be set only once");return s.bind(this),this.resource=s,this}update(){this.valid?(this.dirtyId++,this.dirtyStyleId++,this.emit("update",this)):this.width>0&&this.height>0&&(this.valid=!0,this.emit("loaded",this),this.emit("update",this))}onError(s){this.emit("error",this,s)}destroy(){this.resource&&(this.resource.unbind(this),this.resource.internal&&this.resource.destroy(),this.resource=null),this.cacheId&&(delete G[this.cacheId],delete B[this.cacheId],this.cacheId=null),this.dispose(),te.removeFromCache(this),this.textureCacheIds=null,this.destroyed=!0}dispose(){this.emit("dispose",this)}castToBaseTexture(){return this}static from(s,e,t=m.STRICT_TEXTURE_CACHE){const r=typeof s=="string";let i=null;if(r)i=s;else{if(!s._pixiId){const a=e?.pixiIdPrefix||"pixiid";s._pixiId=`${a}_${ee()}`}i=s._pixiId}let n=G[i];if(r&&t&&!n)throw new Error(`The cacheId "${i}" does not exist in BaseTextureCache.`);return n||(n=new te(s,e),n.cacheId=i,te.addToCache(n,i)),n}static fromBuffer(s,e,t,r){s=s||new Float32Array(e*t*4);const i=new ce(s,{width:e,height:t}),n=s instanceof Float32Array?x.FLOAT:x.UNSIGNED_BYTE;return new te(i,Object.assign(br,r||{width:e,height:t,type:n}))}static addToCache(s,e){e&&(s.textureCacheIds.includes(e)||s.textureCacheIds.push(e),G[e]&&console.warn(`BaseTexture added to the cache with an id [${e}] that already had an entry`),G[e]=s)}static removeFromCache(s){if(typeof s=="string"){const e=G[s];if(e){const t=e.textureCacheIds.indexOf(s);return t>-1&&e.textureCacheIds.splice(t,1),delete G[s],e}}else if(s?.textureCacheIds){for(let e=0;e<s.textureCacheIds.length;++e)delete G[s.textureCacheIds[e]];return s.textureCacheIds.length=0,s}return null}};let y=te;y._globalBatch=0;class Ce extends q{constructor(e,t){const{width:r,height:i}=t||{};super(r,i),this.items=[],this.itemDirtyIds=[];for(let n=0;n<e;n++){const a=new y;this.items.push(a),this.itemDirtyIds.push(-2)}this.length=e,this._load=null,this.baseTexture=null}initFromArray(e,t){for(let r=0;r<this.length;r++)!e[r]||(e[r].castToBaseTexture?this.addBaseTextureAt(e[r].castToBaseTexture(),r):e[r]instanceof q?this.addResourceAt(e[r],r):this.addResourceAt(Ie(e[r],t),r))}dispose(){for(let e=0,t=this.length;e<t;e++)this.items[e].destroy();this.items=null,this.itemDirtyIds=null,this._load=null}addResourceAt(e,t){if(!this.items[t])throw new Error(`Index ${t} is out of bounds`);return e.valid&&!this.valid&&this.resize(e.width,e.height),this.items[t].setResource(e),this}bind(e){if(this.baseTexture!==null)throw new Error("Only one base texture per TextureArray is allowed");super.bind(e);for(let t=0;t<this.length;t++)this.items[t].parentTextureArray=e,this.items[t].on("update",e.update,e)}unbind(e){super.unbind(e);for(let t=0;t<this.length;t++)this.items[t].parentTextureArray=null,this.items[t].off("update",e.update,e)}load(){if(this._load)return this._load;const e=this.items.map(t=>t.resource).filter(t=>t).map(t=>t.load());return this._load=Promise.all(e).then(()=>{const{realWidth:t,realHeight:r}=this.items[0];return this.resize(t,r),Promise.resolve(this)}),this._load}}class St extends Ce{constructor(e,t){const{width:r,height:i}=t||{};let n,a;Array.isArray(e)?(n=e,a=e.length):a=e,super(a,{width:r,height:i}),n&&this.initFromArray(n,t)}addBaseTextureAt(e,t){if(e.resource)this.addResourceAt(e.resource,t);else throw new Error("ArrayResource does not support RenderTexture");return this}bind(e){super.bind(e),e.target=Q.TEXTURE_2D_ARRAY}upload(e,t,r){const{length:i,itemDirtyIds:n,items:a}=this,{gl:o}=e;r.dirtyId<0&&o.texImage3D(o.TEXTURE_2D_ARRAY,0,r.internalFormat,this._width,this._height,i,0,t.format,r.type,null);for(let h=0;h<i;h++){const u=a[h];n[h]<u.dirtyId&&(n[h]=u.dirtyId,u.valid&&o.texSubImage3D(o.TEXTURE_2D_ARRAY,0,0,0,h,u.resource.width,u.resource.height,1,t.format,r.type,u.resource.source))}return!0}}class N extends q{constructor(e){const t=e,r=t.naturalWidth||t.videoWidth||t.width,i=t.naturalHeight||t.videoHeight||t.height;super(r,i),this.source=e,this.noSubImage=!1}static crossOrigin(e,t,r){r===void 0&&!t.startsWith("data:")?e.crossOrigin=fr(t):r!==!1&&(e.crossOrigin=typeof r=="string"?r:"anonymous")}upload(e,t,r,i){const n=e.gl,a=t.realWidth,o=t.realHeight;if(i=i||this.source,i instanceof HTMLImageElement){if(!i.complete||i.naturalWidth===0)return!1}else if(i instanceof HTMLVideoElement&&i.readyState<=1)return!1;return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.alphaMode===j.UNPACK),!this.noSubImage&&t.target===n.TEXTURE_2D&&r.width===a&&r.height===o?n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.format,r.type,i):(r.width=a,r.height=o,n.texImage2D(t.target,0,r.internalFormat,t.format,r.type,i)),!0}update(){if(this.destroyed)return;const e=this.source,t=e.naturalWidth||e.videoWidth||e.width,r=e.naturalHeight||e.videoHeight||e.height;this.resize(t,r),super.update()}dispose(){this.source=null}}class Rt extends N{constructor(e){super(e)}static test(e){const{OffscreenCanvas:t}=globalThis;return t&&e instanceof t?!0:globalThis.HTMLCanvasElement&&e instanceof HTMLCanvasElement}}const re=class extends Ce{constructor(s,e){const{width:t,height:r,autoLoad:i,linkBaseTexture:n}=e||{};if(s&&s.length!==re.SIDES)throw new Error(`Invalid length. Got ${s.length}, expected 6`);super(6,{width:t,height:r});for(let a=0;a<re.SIDES;a++)this.items[a].target=Q.TEXTURE_CUBE_MAP_POSITIVE_X+a;this.linkBaseTexture=n!==!1,s&&this.initFromArray(s,e),i!==!1&&this.load()}bind(s){super.bind(s),s.target=Q.TEXTURE_CUBE_MAP}addBaseTextureAt(s,e,t){if(t===void 0&&(t=this.linkBaseTexture),!this.items[e])throw new Error(`Index ${e} is out of bounds`);if(!this.linkBaseTexture||s.parentTextureArray||Object.keys(s._glTextures).length>0)if(s.resource)this.addResourceAt(s.resource,e);else throw new Error("CubeResource does not support copying of renderTexture.");else s.target=Q.TEXTURE_CUBE_MAP_POSITIVE_X+e,s.parentTextureArray=this.baseTexture,this.items[e]=s;return s.valid&&!this.valid&&this.resize(s.realWidth,s.realHeight),this.items[e]=s,this}upload(s,e,t){const r=this.itemDirtyIds;for(let i=0;i<re.SIDES;i++){const n=this.items[i];(r[i]<n.dirtyId||t.dirtyId<e.dirtyId)&&(n.valid&&n.resource?(n.resource.upload(s,n,t),r[i]=n.dirtyId):r[i]<-1&&(s.gl.texImage2D(n.target,0,t.internalFormat,e.realWidth,e.realHeight,0,e.format,t.type,null),r[i]=-1))}return!0}static test(s){return Array.isArray(s)&&s.length===re.SIDES}};let Fe=re;Fe.SIDES=6;class Me extends N{constructor(e,t){if(t=t||{},!(e instanceof HTMLImageElement)){const r=new Image;N.crossOrigin(r,e,t.crossorigin),r.src=e,e=r}super(e),!e.complete&&!!this._width&&!!this._height&&(this._width=0,this._height=0),this.url=e.src,this._process=null,this.preserveBitmap=!1,this.createBitmap=(t.createBitmap??m.CREATE_IMAGE_BITMAP)&&!!globalThis.createImageBitmap,this.alphaMode=typeof t.alphaMode=="number"?t.alphaMode:null,this.bitmap=null,this._load=null,t.autoLoad!==!1&&this.load()}load(e){return this._load?this._load:(e!==void 0&&(this.createBitmap=e),this._load=new Promise((t,r)=>{const i=this.source;this.url=i.src;const n=()=>{this.destroyed||(i.onload=null,i.onerror=null,this.resize(i.width,i.height),this._load=null,this.createBitmap?t(this.process()):t(this))};i.complete&&i.src?n():(i.onload=n,i.onerror=a=>{r(a),this.onError.emit(a)})}),this._load)}process(){const e=this.source;if(this._process!==null)return this._process;if(this.bitmap!==null||!globalThis.createImageBitmap)return Promise.resolve(this);const t=globalThis.createImageBitmap,r=!e.crossOrigin||e.crossOrigin==="anonymous";return this._process=fetch(e.src,{mode:r?"cors":"no-cors"}).then(i=>i.blob()).then(i=>t(i,0,0,e.width,e.height,{premultiplyAlpha:this.alphaMode===j.UNPACK?"premultiply":"none"})).then(i=>this.destroyed?Promise.reject():(this.bitmap=i,this.update(),this._process=null,Promise.resolve(this))),this._process}upload(e,t,r){if(typeof this.alphaMode=="number"&&(t.alphaMode=this.alphaMode),!this.createBitmap)return super.upload(e,t,r);if(!this.bitmap&&(this.process(),!this.bitmap))return!1;if(super.upload(e,t,r,this.bitmap),!this.preserveBitmap){let i=!0;const n=t._glTextures;for(const a in n){const o=n[a];if(o!==r&&o.dirtyId!==t.dirtyId){i=!1;break}}i&&(this.bitmap.close&&this.bitmap.close(),this.bitmap=null)}return!0}dispose(){this.source.onload=null,this.source.onerror=null,super.dispose(),this.bitmap&&(this.bitmap.close(),this.bitmap=null),this._process=null,this._load=null}static test(e){return typeof e=="string"||e instanceof HTMLImageElement}}const fe=class extends N{constructor(s,e){e=e||{},super(m.ADAPTER.createCanvas()),this._width=0,this._height=0,this.svg=s,this.scale=e.scale||1,this._overrideWidth=e.width,this._overrideHeight=e.height,this._resolve=null,this._crossorigin=e.crossorigin,this._load=null,e.autoLoad!==!1&&this.load()}load(){return this._load?this._load:(this._load=new Promise(s=>{if(this._resolve=()=>{this.resize(this.source.width,this.source.height),s(this)},fe.SVG_XML.test(this.svg.trim())){if(!btoa)throw new Error("Your browser doesn't support base64 conversions.");this.svg=`data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`}this._loadSvg()}),this._load)}_loadSvg(){const s=new Image;N.crossOrigin(s,this.svg,this._crossorigin),s.src=this.svg,s.onerror=e=>{!this._resolve||(s.onerror=null,this.onError.emit(e))},s.onload=()=>{if(!this._resolve)return;const e=s.width,t=s.height;if(!e||!t)throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");let r=e*this.scale,i=t*this.scale;(this._overrideWidth||this._overrideHeight)&&(r=this._overrideWidth||this._overrideHeight/t*e,i=this._overrideHeight||this._overrideWidth/e*t),r=Math.round(r),i=Math.round(i);const n=this.source;n.width=r,n.height=i,n._pixiId=`canvas_${ee()}`,n.getContext("2d").drawImage(s,0,0,e,t,0,0,r,i),this._resolve(),this._resolve=null}}static getSize(s){const e=fe.SVG_SIZE.exec(s),t={};return e&&(t[e[1]]=Math.round(parseFloat(e[3])),t[e[5]]=Math.round(parseFloat(e[7]))),t}dispose(){super.dispose(),this._resolve=null,this._crossorigin=null}static test(s,e){return e==="svg"||typeof s=="string"&&s.startsWith("data:image/svg+xml")||typeof s=="string"&&fe.SVG_XML.test(s)}};let me=fe;me.SVG_XML=/^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,me.SVG_SIZE=/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;const Be=class extends N{constructor(s,e){if(e=e||{},!(s instanceof HTMLVideoElement)){const t=document.createElement("video");t.setAttribute("preload","auto"),t.setAttribute("webkit-playsinline",""),t.setAttribute("playsinline",""),typeof s=="string"&&(s=[s]);const r=s[0].src||s[0];N.crossOrigin(t,r,e.crossorigin);for(let i=0;i<s.length;++i){const n=document.createElement("source");let{src:a,mime:o}=s[i];a=a||s[i];const h=a.split("?").shift().toLowerCase(),u=h.slice(h.lastIndexOf(".")+1);o=o||Be.MIME_TYPES[u]||`video/${u}`,n.src=a,n.type=o,t.appendChild(n)}s=t}super(s),this.noSubImage=!0,this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=e.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=e.autoPlay!==!1,this._load=null,this._resolve=null,this._onCanPlay=this._onCanPlay.bind(this),this._onError=this._onError.bind(this),e.autoLoad!==!1&&this.load()}update(s=0){if(!this.destroyed){const e=K.shared.elapsedMS*this.source.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-e),(!this._updateFPS||this._msToNextUpdate<=0)&&(super.update(),this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0)}}load(){if(this._load)return this._load;const s=this.source;return(s.readyState===s.HAVE_ENOUGH_DATA||s.readyState===s.HAVE_FUTURE_DATA)&&s.width&&s.height&&(s.complete=!0),s.addEventListener("play",this._onPlayStart.bind(this)),s.addEventListener("pause",this._onPlayStop.bind(this)),this._isSourceReady()?this._onCanPlay():(s.addEventListener("canplay",this._onCanPlay),s.addEventListener("canplaythrough",this._onCanPlay),s.addEventListener("error",this._onError,!0)),this._load=new Promise(e=>{this.valid?e(this):(this._resolve=e,s.load())}),this._load}_onError(s){this.source.removeEventListener("error",this._onError,!0),this.onError.emit(s)}_isSourcePlaying(){const s=this.source;return s.currentTime>0&&s.paused===!1&&s.ended===!1&&s.readyState>2}_isSourceReady(){const s=this.source;return s.readyState===3||s.readyState===4}_onPlayStart(){this.valid||this._onCanPlay(),this.autoUpdate&&!this._isConnectedToTicker&&(K.shared.add(this.update,this),this._isConnectedToTicker=!0)}_onPlayStop(){this._isConnectedToTicker&&(K.shared.remove(this.update,this),this._isConnectedToTicker=!1)}_onCanPlay(){const s=this.source;s.removeEventListener("canplay",this._onCanPlay),s.removeEventListener("canplaythrough",this._onCanPlay);const e=this.valid;this.resize(s.videoWidth,s.videoHeight),!e&&this._resolve&&(this._resolve(this),this._resolve=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&s.play()}dispose(){this._isConnectedToTicker&&(K.shared.remove(this.update,this),this._isConnectedToTicker=!1);const s=this.source;s&&(s.removeEventListener("error",this._onError,!0),s.pause(),s.src="",s.load()),super.dispose()}get autoUpdate(){return this._autoUpdate}set autoUpdate(s){s!==this._autoUpdate&&(this._autoUpdate=s,!this._autoUpdate&&this._isConnectedToTicker?(K.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._isSourcePlaying()&&(K.shared.add(this.update,this),this._isConnectedToTicker=!0))}get updateFPS(){return this._updateFPS}set updateFPS(s){s!==this._updateFPS&&(this._updateFPS=s)}static test(s,e){return globalThis.HTMLVideoElement&&s instanceof HTMLVideoElement||Be.TYPES.includes(e)}};let pe=Be;pe.TYPES=["mp4","m4v","webm","ogg","ogv","h264","avi","mov"],pe.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};class wt extends N{constructor(e){super(e)}static test(e){return!!globalThis.createImageBitmap&&typeof ImageBitmap<"u"&&e instanceof ImageBitmap}}de.push(Me,wt,Rt,pe,me,ce,Fe,St);class yr extends ce{upload(e,t,r){const i=e.gl;i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.alphaMode===j.UNPACK);const n=t.realWidth,a=t.realHeight;return r.width===n&&r.height===a?i.texSubImage2D(t.target,0,0,0,n,a,t.format,r.type,this.data):(r.width=n,r.height=a,i.texImage2D(t.target,0,r.internalFormat,n,a,0,t.format,r.type,this.data)),!0}}class ge{constructor(e,t){this.width=Math.round(e||100),this.height=Math.round(t||100),this.stencil=!1,this.depth=!1,this.dirtyId=0,this.dirtyFormat=0,this.dirtySize=0,this.depthTexture=null,this.colorTextures=[],this.glFramebuffers={},this.disposeRunner=new L("disposeFramebuffer"),this.multisample=S.NONE}get colorTexture(){return this.colorTextures[0]}addColorTexture(e=0,t){return this.colorTextures[e]=t||new y(null,{scaleMode:D.NEAREST,resolution:1,mipmap:J.OFF,width:this.width,height:this.height}),this.dirtyId++,this.dirtyFormat++,this}addDepthTexture(e){return this.depthTexture=e||new y(new yr(null,{width:this.width,height:this.height}),{scaleMode:D.NEAREST,resolution:1,width:this.width,height:this.height,mipmap:J.OFF,format:c.DEPTH_COMPONENT,type:x.UNSIGNED_SHORT}),this.dirtyId++,this.dirtyFormat++,this}enableDepth(){return this.depth=!0,this.dirtyId++,this.dirtyFormat++,this}enableStencil(){return this.stencil=!0,this.dirtyId++,this.dirtyFormat++,this}resize(e,t){if(e=Math.round(e),t=Math.round(t),!(e===this.width&&t===this.height)){this.width=e,this.height=t,this.dirtyId++,this.dirtySize++;for(let r=0;r<this.colorTextures.length;r++){const i=this.colorTextures[r],n=i.resolution;i.setSize(e/n,t/n)}if(this.depthTexture){const r=this.depthTexture.resolution;this.depthTexture.setSize(e/r,t/r)}}}dispose(){this.disposeRunner.emit(this,!1)}destroyDepthTexture(){this.depthTexture&&(this.depthTexture.destroy(),this.depthTexture=null,++this.dirtyId,++this.dirtyFormat)}}class Ne extends y{constructor(e={}){if(typeof e=="number"){const t=arguments[0],r=arguments[1],i=arguments[2],n=arguments[3];e={width:t,height:r,scaleMode:i,resolution:n}}e.width=e.width||100,e.height=e.height||100,e.multisample??(e.multisample=S.NONE),super(null,e),this.mipmap=J.OFF,this.valid=!0,this.clearColor=[0,0,0,0],this.framebuffer=new ge(this.realWidth,this.realHeight).addColorTexture(0,this),this.framebuffer.multisample=e.multisample,this.maskStack=[],this.filterStack=[{}]}resize(e,t){this.framebuffer.resize(e*this.resolution,t*this.resolution),this.setRealSize(this.framebuffer.width,this.framebuffer.height)}dispose(){this.framebuffer.dispose(),super.dispose()}destroy(){super.destroy(),this.framebuffer.destroyDepthTexture(),this.framebuffer=null}}class Oe{constructor(){this.x0=0,this.y0=0,this.x1=1,this.y1=0,this.x2=1,this.y2=1,this.x3=0,this.y3=1,this.uvsFloat32=new Float32Array(8)}set(e,t,r){const i=t.width,n=t.height;if(r){const a=e.width/2/i,o=e.height/2/n,h=e.x/i+a,u=e.y/n+o;r=C.add(r,C.NW),this.x0=h+a*C.uX(r),this.y0=u+o*C.uY(r),r=C.add(r,2),this.x1=h+a*C.uX(r),this.y1=u+o*C.uY(r),r=C.add(r,2),this.x2=h+a*C.uX(r),this.y2=u+o*C.uY(r),r=C.add(r,2),this.x3=h+a*C.uX(r),this.y3=u+o*C.uY(r)}else this.x0=e.x/i,this.y0=e.y/n,this.x1=(e.x+e.width)/i,this.y1=e.y/n,this.x2=(e.x+e.width)/i,this.y2=(e.y+e.height)/n,this.x3=e.x/i,this.y3=(e.y+e.height)/n;this.uvsFloat32[0]=this.x0,this.uvsFloat32[1]=this.y0,this.uvsFloat32[2]=this.x1,this.uvsFloat32[3]=this.y1,this.uvsFloat32[4]=this.x2,this.uvsFloat32[5]=this.y2,this.uvsFloat32[6]=this.x3,this.uvsFloat32[7]=this.y3}}const At=new Oe;function _e(s){s.destroy=function(){},s.on=function(){},s.once=function(){},s.emit=function(){}}class E extends Ae{constructor(e,t,r,i,n,a){if(super(),this.noFrame=!1,t||(this.noFrame=!0,t=new w(0,0,1,1)),e instanceof E&&(e=e.baseTexture),this.baseTexture=e,this._frame=t,this.trim=i,this.valid=!1,this._uvs=At,this.uvMatrix=null,this.orig=r||t,this._rotate=Number(n||0),n===!0)this._rotate=2;else if(this._rotate%2!==0)throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");this.defaultAnchor=a?new Y(a.x,a.y):new Y(0,0),this._updateID=0,this.textureCacheIds=[],e.valid?this.noFrame?e.valid&&this.onBaseTextureUpdated(e):this.frame=t:e.once("loaded",this.onBaseTextureUpdated,this),this.noFrame&&e.on("update",this.onBaseTextureUpdated,this)}update(){this.baseTexture.resource&&this.baseTexture.resource.update()}onBaseTextureUpdated(e){if(this.noFrame){if(!this.baseTexture.valid)return;this._frame.width=e.width,this._frame.height=e.height,this.valid=!0,this.updateUvs()}else this.frame=this._frame;this.emit("update",this)}destroy(e){if(this.baseTexture){if(e){const{resource:t}=this.baseTexture;t?.url&&B[t.url]&&E.removeFromCache(t.url),this.baseTexture.destroy()}this.baseTexture.off("loaded",this.onBaseTextureUpdated,this),this.baseTexture.off("update",this.onBaseTextureUpdated,this),this.baseTexture=null}this._frame=null,this._uvs=null,this.trim=null,this.orig=null,this.valid=!1,E.removeFromCache(this),this.textureCacheIds=null}clone(){const e=this._frame.clone(),t=this._frame===this.orig?e:this.orig.clone(),r=new E(this.baseTexture,!this.noFrame&&e,t,this.trim?.clone(),this.rotate,this.defaultAnchor);return this.noFrame&&(r._frame=e),r}updateUvs(){this._uvs===At&&(this._uvs=new Oe),this._uvs.set(this._frame,this.baseTexture,this.rotate),this._updateID++}static from(e,t={},r=m.STRICT_TEXTURE_CACHE){const i=typeof e=="string";let n=null;if(i)n=e;else if(e instanceof y){if(!e.cacheId){const o=t?.pixiIdPrefix||"pixiid";e.cacheId=`${o}-${ee()}`,y.addToCache(e,e.cacheId)}n=e.cacheId}else{if(!e._pixiId){const o=t?.pixiIdPrefix||"pixiid";e._pixiId=`${o}_${ee()}`}n=e._pixiId}let a=B[n];if(i&&r&&!a)throw new Error(`The cacheId "${n}" does not exist in TextureCache.`);return!a&&!(e instanceof y)?(t.resolution||(t.resolution=Et(e)),a=new E(new y(e,t)),a.baseTexture.cacheId=n,y.addToCache(a.baseTexture,n),E.addToCache(a,n)):!a&&e instanceof y&&(a=new E(e),E.addToCache(a,n)),a}static fromURL(e,t){const r=Object.assign({autoLoad:!1},t?.resourceOptions),i=E.from(e,Object.assign({resourceOptions:r},t),!1),n=i.baseTexture.resource;return i.baseTexture.valid?Promise.resolve(i):n.load().then(()=>Promise.resolve(i))}static fromBuffer(e,t,r,i){return new E(y.fromBuffer(e,t,r,i))}static fromLoader(e,t,r,i){const n=new y(e,Object.assign({scaleMode:m.SCALE_MODE,resolution:Et(t)},i)),{resource:a}=n;a instanceof Me&&(a.url=t);const o=new E(n);return r||(r=t),y.addToCache(o.baseTexture,r),E.addToCache(o,r),r!==t&&(y.addToCache(o.baseTexture,t),E.addToCache(o,t)),o.baseTexture.valid?Promise.resolve(o):new Promise(h=>{o.baseTexture.once("loaded",()=>h(o))})}static addToCache(e,t){t&&(e.textureCacheIds.includes(t)||e.textureCacheIds.push(t),B[t]&&console.warn(`Texture added to the cache with an id [${t}] that already had an entry`),B[t]=e)}static removeFromCache(e){if(typeof e=="string"){const t=B[e];if(t){const r=t.textureCacheIds.indexOf(e);return r>-1&&t.textureCacheIds.splice(r,1),delete B[e],t}}else if(e?.textureCacheIds){for(let t=0;t<e.textureCacheIds.length;++t)B[e.textureCacheIds[t]]===e&&delete B[e.textureCacheIds[t]];return e.textureCacheIds.length=0,e}return null}get resolution(){return this.baseTexture.resolution}get frame(){return this._frame}set frame(e){this._frame=e,this.noFrame=!1;const{x:t,y:r,width:i,height:n}=e,a=t+i>this.baseTexture.width,o=r+n>this.baseTexture.height;if(a||o){const h=a&&o?"and":"or",u=`X: ${t} + ${i} = ${t+i} > ${this.baseTexture.width}`,l=`Y: ${r} + ${n} = ${r+n} > ${this.baseTexture.height}`;throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${u} ${h} ${l}`)}this.valid=i&&n&&this.baseTexture.valid,!this.trim&&!this.rotate&&(this.orig=e),this.valid&&this.updateUvs()}get rotate(){return this._rotate}set rotate(e){this._rotate=e,this.valid&&this.updateUvs()}get width(){return this.orig.width}get height(){return this.orig.height}castToBaseTexture(){return this.baseTexture}static get EMPTY(){return E._EMPTY||(E._EMPTY=new E(new y),_e(E._EMPTY),_e(E._EMPTY.baseTexture)),E._EMPTY}static get WHITE(){if(!E._WHITE){const e=m.ADAPTER.createCanvas(16,16),t=e.getContext("2d");e.width=16,e.height=16,t.fillStyle="white",t.fillRect(0,0,16,16),E._WHITE=new E(y.from(e)),_e(E._WHITE),_e(E._WHITE.baseTexture)}return E._WHITE}}class ae extends E{constructor(e,t){super(e,t),this.valid=!0,this.filterFrame=null,this.filterPoolKey=null,this.updateUvs()}get framebuffer(){return this.baseTexture.framebuffer}get multisample(){return this.framebuffer.multisample}set multisample(e){this.framebuffer.multisample=e}resize(e,t,r=!0){const i=this.baseTexture.resolution,n=Math.round(e*i)/i,a=Math.round(t*i)/i;this.valid=n>0&&a>0,this._frame.width=this.orig.width=n,this._frame.height=this.orig.height=a,r&&this.baseTexture.resize(n,a),this.updateUvs()}setResolution(e){const{baseTexture:t}=this;t.resolution!==e&&(t.setResolution(e),this.resize(t.width,t.height,!1))}static create(e){return new ae(new Ne(e))}}class Pe{constructor(e){this.texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1,this._pixelsWidth=0,this._pixelsHeight=0}createTexture(e,t,r=S.NONE){const i=new Ne(Object.assign({width:e,height:t,resolution:1,multisample:r},this.textureOptions));return new ae(i)}getOptimalTexture(e,t,r=1,i=S.NONE){let n;e=Math.ceil(e*r-1e-6),t=Math.ceil(t*r-1e-6),!this.enableFullScreen||e!==this._pixelsWidth||t!==this._pixelsHeight?(e=le(e),t=le(t),n=((e&65535)<<16|t&65535)>>>0,i>1&&(n+=i*4294967296)):n=i>1?-i:-1,this.texturePool[n]||(this.texturePool[n]=[]);let a=this.texturePool[n].pop();return a||(a=this.createTexture(e,t,i)),a.filterPoolKey=n,a.setResolution(r),a}getFilterTexture(e,t,r){const i=this.getOptimalTexture(e.width,e.height,t||e.resolution,r||S.NONE);return i.filterFrame=e.filterFrame,i}returnTexture(e){const t=e.filterPoolKey;e.filterFrame=null,this.texturePool[t].push(e)}returnFilterTexture(e){this.returnTexture(e)}clear(e){if(e=e!==!1,e)for(const t in this.texturePool){const r=this.texturePool[t];if(r)for(let i=0;i<r.length;i++)r[i].destroy(!0)}this.texturePool={}}setScreenSize(e){if(!(e.width===this._pixelsWidth&&e.height===this._pixelsHeight)){this.enableFullScreen=e.width>0&&e.height>0;for(const t in this.texturePool){if(!(Number(t)<0))continue;const r=this.texturePool[t];if(r)for(let i=0;i<r.length;i++)r[i].destroy(!0);this.texturePool[t]=[]}this._pixelsWidth=e.width,this._pixelsHeight=e.height}}}Pe.SCREEN_KEY=-1;class oe{constructor(e,t=0,r=!1,i=x.FLOAT,n,a,o){this.buffer=e,this.size=t,this.normalized=r,this.type=i,this.stride=n,this.start=a,this.instance=o}destroy(){this.buffer=null}static from(e,t,r,i,n){return new oe(e,t,r,i,n)}}let Sr=0;class A{constructor(e,t=!0,r=!1){this.data=e||new Float32Array(1),this._glBuffers={},this._updateID=0,this.index=r,this.static=t,this.id=Sr++,this.disposeRunner=new L("disposeBuffer")}update(e){e instanceof Array&&(e=new Float32Array(e)),this.data=e||this.data,this._updateID++}dispose(){this.disposeRunner.emit(this,!1)}destroy(){this.dispose(),this.data=null}set index(e){this.type=e?O.ELEMENT_ARRAY_BUFFER:O.ARRAY_BUFFER}get index(){return this.type===O.ELEMENT_ARRAY_BUFFER}static from(e){return e instanceof Array&&(e=new Float32Array(e)),new A(e)}}const Rr={Float32Array,Uint32Array,Int32Array,Uint8Array};function wr(s,e){let t=0,r=0;const i={};for(let h=0;h<s.length;h++)r+=e[h],t+=s[h].length;const n=new ArrayBuffer(t*4);let a=null,o=0;for(let h=0;h<s.length;h++){const u=e[h],l=s[h],d=Tt(l);i[d]||(i[d]=new Rr[d](n)),a=i[d];for(let f=0;f<l.length;f++){const p=(f/u|0)*r+o,b=f%u;a[p+b]=l[f]}o+=u}return new Float32Array(n)}const It={5126:4,5123:2,5121:1};let Ar=0;const Ir={Float32Array,Uint32Array,Int32Array,Uint8Array,Uint16Array};class X{constructor(e=[],t={}){this.buffers=e,this.indexBuffer=null,this.attributes=t,this.glVertexArrayObjects={},this.id=Ar++,this.instanced=!1,this.instanceCount=1,this.disposeRunner=new L("disposeGeometry"),this.refCount=0}addAttribute(e,t,r=0,i=!1,n,a,o,h=!1){if(!t)throw new Error("You must pass a buffer when creating an attribute");t instanceof A||(t instanceof Array&&(t=new Float32Array(t)),t=new A(t));const u=e.split("|");if(u.length>1){for(let d=0;d<u.length;d++)this.addAttribute(u[d],t,r,i,n);return this}let l=this.buffers.indexOf(t);return l===-1&&(this.buffers.push(t),l=this.buffers.length-1),this.attributes[e]=new oe(l,r,i,n,a,o,h),this.instanced=this.instanced||h,this}getAttribute(e){return this.attributes[e]}getBuffer(e){return this.buffers[this.getAttribute(e).buffer]}addIndex(e){return e instanceof A||(e instanceof Array&&(e=new Uint16Array(e)),e=new A(e)),e.type=O.ELEMENT_ARRAY_BUFFER,this.indexBuffer=e,this.buffers.includes(e)||this.buffers.push(e),this}getIndex(){return this.indexBuffer}interleave(){if(this.buffers.length===1||this.buffers.length===2&&this.indexBuffer)return this;const e=[],t=[],r=new A;let i;for(i in this.attributes){const n=this.attributes[i],a=this.buffers[n.buffer];e.push(a.data),t.push(n.size*It[n.type]/4),n.buffer=0}for(r.data=wr(e,t),i=0;i<this.buffers.length;i++)this.buffers[i]!==this.indexBuffer&&this.buffers[i].destroy();return this.buffers=[r],this.indexBuffer&&this.buffers.push(this.indexBuffer),this}getSize(){for(const e in this.attributes){const t=this.attributes[e];return this.buffers[t.buffer].data.length/(t.stride/4||t.size)}return 0}dispose(){this.disposeRunner.emit(this,!1)}destroy(){this.dispose(),this.buffers=null,this.indexBuffer=null,this.attributes=null}clone(){const e=new X;for(let t=0;t<this.buffers.length;t++)e.buffers[t]=new A(this.buffers[t].data.slice(0));for(const t in this.attributes){const r=this.attributes[t];e.attributes[t]=new oe(r.buffer,r.size,r.normalized,r.type,r.stride,r.start,r.instance)}return this.indexBuffer&&(e.indexBuffer=e.buffers[this.buffers.indexOf(this.indexBuffer)],e.indexBuffer.type=O.ELEMENT_ARRAY_BUFFER),e}static merge(e){const t=new X,r=[],i=[],n=[];let a;for(let o=0;o<e.length;o++){a=e[o];for(let h=0;h<a.buffers.length;h++)i[h]=i[h]||0,i[h]+=a.buffers[h].data.length,n[h]=0}for(let o=0;o<a.buffers.length;o++)r[o]=new Ir[Tt(a.buffers[o].data)](i[o]),t.buffers[o]=new A(r[o]);for(let o=0;o<e.length;o++){a=e[o];for(let h=0;h<a.buffers.length;h++)r[h].set(a.buffers[h].data,n[h]),n[h]+=a.buffers[h].data.length}if(t.attributes=a.attributes,a.indexBuffer){t.indexBuffer=t.buffers[a.buffers.indexOf(a.indexBuffer)],t.indexBuffer.type=O.ELEMENT_ARRAY_BUFFER;let o=0,h=0,u=0,l=0;for(let d=0;d<a.buffers.length;d++)if(a.buffers[d]!==a.indexBuffer){l=d;break}for(const d in a.attributes){const f=a.attributes[d];(f.buffer|0)===l&&(h+=f.size*It[f.type]/4)}for(let d=0;d<e.length;d++){const f=e[d].indexBuffer.data;for(let p=0;p<f.length;p++)t.indexBuffer.data[p+u]+=o;o+=e[d].buffers[l].data.length/h,u+=f.length}}return t}}class Ct extends X{constructor(){super(),this.addAttribute("aVertexPosition",new Float32Array([0,0,1,0,1,1,0,1])).addIndex([0,1,3,2])}}class Ft extends X{constructor(){super(),this.vertices=new Float32Array([-1,-1,1,-1,1,1,-1,1]),this.uvs=new Float32Array([0,0,1,0,1,1,0,1]),this.vertexBuffer=new A(this.vertices),this.uvBuffer=new A(this.uvs),this.addAttribute("aVertexPosition",this.vertexBuffer).addAttribute("aTextureCoord",this.uvBuffer).addIndex([0,1,2,0,2,3])}map(e,t){let r=0,i=0;return this.uvs[0]=r,this.uvs[1]=i,this.uvs[2]=r+t.width/e.width,this.uvs[3]=i,this.uvs[4]=r+t.width/e.width,this.uvs[5]=i+t.height/e.height,this.uvs[6]=r,this.uvs[7]=i+t.height/e.height,r=t.x,i=t.y,this.vertices[0]=r,this.vertices[1]=i,this.vertices[2]=r+t.width,this.vertices[3]=i,this.vertices[4]=r+t.width,this.vertices[5]=i+t.height,this.vertices[6]=r,this.vertices[7]=i+t.height,this.invalidate(),this}invalidate(){return this.vertexBuffer._updateID++,this.uvBuffer._updateID++,this}}let Cr=0;class F{constructor(e,t,r){this.group=!0,this.syncUniforms={},this.dirtyId=0,this.id=Cr++,this.static=!!t,this.ubo=!!r,e instanceof A?(this.buffer=e,this.buffer.type=O.UNIFORM_BUFFER,this.autoManage=!1,this.ubo=!0):(this.uniforms=e,this.ubo&&(this.buffer=new A(new Float32Array(1)),this.buffer.type=O.UNIFORM_BUFFER,this.autoManage=!0))}update(){this.dirtyId++,!this.autoManage&&this.buffer&&this.buffer.update()}add(e,t,r){if(!this.ubo)this.uniforms[e]=new F(t,r);else throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")}static from(e,t,r){return new F(e,t,r)}static uboFrom(e,t){return new F(e,t??!0,!0)}}class Mt{constructor(){this.renderTexture=null,this.target=null,this.legacy=!1,this.resolution=1,this.multisample=S.NONE,this.sourceFrame=new w,this.destinationFrame=new w,this.bindingSourceFrame=new w,this.bindingDestinationFrame=new w,this.filters=[],this.transform=null}clear(){this.target=null,this.filters=null,this.renderTexture=null}}const xe=[new Y,new Y,new Y,new Y],Ue=new M;class De{constructor(e){this.renderer=e,this.defaultFilterStack=[{}],this.texturePool=new Pe,this.statePool=[],this.quad=new Ct,this.quadUv=new Ft,this.tempRect=new w,this.activeState={},this.globalUniforms=new F({outputFrame:new w,inputSize:new Float32Array(4),inputPixel:new Float32Array(4),inputClamp:new Float32Array(4),resolution:1,filterArea:new Float32Array(4),filterClamp:new Float32Array(4)},!0),this.forceClear=!1,this.useMaxPadding=!1}init(){this.texturePool.setScreenSize(this.renderer.view)}push(e,t){const r=this.renderer,i=this.defaultFilterStack,n=this.statePool.pop()||new Mt,a=this.renderer.renderTexture;let o=t[0].resolution,h=t[0].multisample,u=t[0].padding,l=t[0].autoFit,d=t[0].legacy??!0;for(let b=1;b<t.length;b++){const v=t[b];o=Math.min(o,v.resolution),h=Math.min(h,v.multisample),u=this.useMaxPadding?Math.max(u,v.padding):u+v.padding,l=l&&v.autoFit,d=d||(v.legacy??!0)}i.length===1&&(this.defaultFilterStack[0].renderTexture=a.current),i.push(n),n.resolution=o,n.multisample=h,n.legacy=d,n.target=e,n.sourceFrame.copyFrom(e.filterArea||e.getBounds(!0)),n.sourceFrame.pad(u);const f=this.tempRect.copyFrom(a.sourceFrame);r.projection.transform&&this.transformAABB(Ue.copyFrom(r.projection.transform).invert(),f),l?(n.sourceFrame.fit(f),(n.sourceFrame.width<=0||n.sourceFrame.height<=0)&&(n.sourceFrame.width=0,n.sourceFrame.height=0)):n.sourceFrame.intersects(f)||(n.sourceFrame.width=0,n.sourceFrame.height=0),this.roundFrame(n.sourceFrame,a.current?a.current.resolution:r.resolution,a.sourceFrame,a.destinationFrame,r.projection.transform),n.renderTexture=this.getOptimalFilterTexture(n.sourceFrame.width,n.sourceFrame.height,o,h),n.filters=t,n.destinationFrame.width=n.renderTexture.width,n.destinationFrame.height=n.renderTexture.height;const p=this.tempRect;p.x=0,p.y=0,p.width=n.sourceFrame.width,p.height=n.sourceFrame.height,n.renderTexture.filterFrame=n.sourceFrame,n.bindingSourceFrame.copyFrom(a.sourceFrame),n.bindingDestinationFrame.copyFrom(a.destinationFrame),n.transform=r.projection.transform,r.projection.transform=null,a.bind(n.renderTexture,n.sourceFrame,p),r.framebuffer.clear(0,0,0,0)}pop(){const e=this.defaultFilterStack,t=e.pop(),r=t.filters;this.activeState=t;const i=this.globalUniforms.uniforms;i.outputFrame=t.sourceFrame,i.resolution=t.resolution;const n=i.inputSize,a=i.inputPixel,o=i.inputClamp;if(n[0]=t.destinationFrame.width,n[1]=t.destinationFrame.height,n[2]=1/n[0],n[3]=1/n[1],a[0]=Math.round(n[0]*t.resolution),a[1]=Math.round(n[1]*t.resolution),a[2]=1/a[0],a[3]=1/a[1],o[0]=.5*a[2],o[1]=.5*a[3],o[2]=t.sourceFrame.width*n[2]-.5*a[2],o[3]=t.sourceFrame.height*n[3]-.5*a[3],t.legacy){const u=i.filterArea;u[0]=t.destinationFrame.width,u[1]=t.destinationFrame.height,u[2]=t.sourceFrame.x,u[3]=t.sourceFrame.y,i.filterClamp=i.inputClamp}this.globalUniforms.update();const h=e[e.length-1];if(this.renderer.framebuffer.blit(),r.length===1)r[0].apply(this,t.renderTexture,h.renderTexture,W.BLEND,t),this.returnFilterTexture(t.renderTexture);else{let u=t.renderTexture,l=this.getOptimalFilterTexture(u.width,u.height,t.resolution);l.filterFrame=u.filterFrame;let d=0;for(d=0;d<r.length-1;++d){d===1&&t.multisample>1&&(l=this.getOptimalFilterTexture(u.width,u.height,t.resolution),l.filterFrame=u.filterFrame),r[d].apply(this,u,l,W.CLEAR,t);const f=u;u=l,l=f}r[d].apply(this,u,h.renderTexture,W.BLEND,t),d>1&&t.multisample>1&&this.returnFilterTexture(t.renderTexture),this.returnFilterTexture(u),this.returnFilterTexture(l)}t.clear(),this.statePool.push(t)}bindAndClear(e,t=W.CLEAR){const{renderTexture:r,state:i}=this.renderer;if(e===this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?this.renderer.projection.transform=this.activeState.transform:this.renderer.projection.transform=null,e?.filterFrame){const a=this.tempRect;a.x=0,a.y=0,a.width=e.filterFrame.width,a.height=e.filterFrame.height,r.bind(e,e.filterFrame,a)}else e!==this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?r.bind(e):this.renderer.renderTexture.bind(e,this.activeState.bindingSourceFrame,this.activeState.bindingDestinationFrame);const n=i.stateId&1||this.forceClear;(t===W.CLEAR||t===W.BLIT&&n)&&this.renderer.framebuffer.clear(0,0,0,0)}applyFilter(e,t,r,i){const n=this.renderer;n.state.set(e.state),this.bindAndClear(r,i),e.uniforms.uSampler=t,e.uniforms.filterGlobals=this.globalUniforms,n.shader.bind(e),e.legacy=!!e.program.attributeData.aTextureCoord,e.legacy?(this.quadUv.map(t._frame,t.filterFrame),n.geometry.bind(this.quadUv),n.geometry.draw(we.TRIANGLES)):(n.geometry.bind(this.quad),n.geometry.draw(we.TRIANGLE_STRIP))}calculateSpriteMatrix(e,t){const{sourceFrame:r,destinationFrame:i}=this.activeState,{orig:n}=t._texture,a=e.set(i.width,0,0,i.height,r.x,r.y),o=t.worldTransform.copyTo(M.TEMP_MATRIX);return o.invert(),a.prepend(o),a.scale(1/n.width,1/n.height),a.translate(t.anchor.x,t.anchor.y),a}destroy(){this.renderer=null,this.texturePool.clear(!1)}getOptimalFilterTexture(e,t,r=1,i=S.NONE){return this.texturePool.getOptimalTexture(e,t,r,i)}getFilterTexture(e,t,r){if(typeof e=="number"){const n=e;e=t,t=n}e=e||this.activeState.renderTexture;const i=this.texturePool.getOptimalTexture(e.width,e.height,t||e.resolution,r||S.NONE);return i.filterFrame=e.filterFrame,i}returnFilterTexture(e){this.texturePool.returnTexture(e)}emptyPool(){this.texturePool.clear(!0)}resize(){this.texturePool.setScreenSize(this.renderer.view)}transformAABB(e,t){const r=xe[0],i=xe[1],n=xe[2],a=xe[3];r.set(t.left,t.top),i.set(t.left,t.bottom),n.set(t.right,t.top),a.set(t.right,t.bottom),e.apply(r,r),e.apply(i,i),e.apply(n,n),e.apply(a,a);const o=Math.min(r.x,i.x,n.x,a.x),h=Math.min(r.y,i.y,n.y,a.y),u=Math.max(r.x,i.x,n.x,a.x),l=Math.max(r.y,i.y,n.y,a.y);t.x=o,t.y=h,t.width=u-o,t.height=l-h}roundFrame(e,t,r,i,n){if(!(e.width<=0||e.height<=0||r.width<=0||r.height<=0)){if(n){const{a,b:o,c:h,d:u}=n;if((Math.abs(o)>1e-4||Math.abs(h)>1e-4)&&(Math.abs(a)>1e-4||Math.abs(u)>1e-4))return}n=n?Ue.copyFrom(n):Ue.identity(),n.translate(-r.x,-r.y).scale(i.width/r.width,i.height/r.height).translate(i.x,i.y),this.transformAABB(n,e),e.ceil(t),this.transformAABB(n.invert(),e)}}}De.extension={type:_.RendererSystem,name:"filter"},T.add(De);class Le{constructor(e){this.renderer=e}flush(){}destroy(){this.renderer=null}start(){}stop(){this.flush()}render(e){}}class Ge{constructor(e){this.renderer=e,this.emptyRenderer=new Le(e),this.currentRenderer=this.emptyRenderer}setObjectRenderer(e){this.currentRenderer!==e&&(this.currentRenderer.stop(),this.currentRenderer=e,this.currentRenderer.start())}flush(){this.setObjectRenderer(this.emptyRenderer)}reset(){this.setObjectRenderer(this.emptyRenderer)}copyBoundTextures(e,t){const{boundTextures:r}=this.renderer.texture;for(let i=t-1;i>=0;--i)e[i]=r[i]||null,e[i]&&(e[i]._batchLocation=i)}boundArray(e,t,r,i){const{elements:n,ids:a,count:o}=e;let h=0;for(let u=0;u<o;u++){const l=n[u],d=l._batchLocation;if(d>=0&&d<i&&t[d]===l){a[u]=d;continue}for(;h<i;){const f=t[h];if(f&&f._batchEnabled===r&&f._batchLocation===h){h++;continue}a[u]=h,l._batchLocation=h,t[h]=l;break}}}destroy(){this.renderer=null}}Ge.extension={type:_.RendererSystem,name:"batch"},T.add(Ge);let Bt=0;class ke{constructor(e){this.renderer=e,this.webGLVersion=1,this.extensions={},this.supports={uint32Indices:!1},this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(e){this.gl=e,this.renderer.gl=e,this.renderer.CONTEXT_UID=Bt++,e.isContextLost()&&e.getExtension("WEBGL_lose_context")&&e.getExtension("WEBGL_lose_context").restoreContext()}init(e){if(e.context)this.initFromContext(e.context);else{const t=this.renderer.background.alpha<1,r=e.premultipliedAlpha??!0;this.preserveDrawingBuffer=e.preserveDrawingBuffer,this.useContextAlpha=e.useContextAlpha,this.powerPreference=e.powerPreference,this.initFromOptions({alpha:t,premultipliedAlpha:r,antialias:e.antialias,stencil:!0,preserveDrawingBuffer:e.preserveDrawingBuffer,powerPreference:e.powerPreference})}}initFromContext(e){this.gl=e,this.validateContext(e),this.renderer.gl=e,this.renderer.CONTEXT_UID=Bt++,this.renderer.runners.contextChange.emit(e),this.renderer.view.addEventListener("webglcontextlost",this.handleContextLost,!1),this.renderer.view.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}initFromOptions(e){const t=this.createContext(this.renderer.view,e);this.initFromContext(t)}createContext(e,t){let r;if(m.PREFER_ENV>=z.WEBGL2&&(r=e.getContext("webgl2",t)),r)this.webGLVersion=2;else if(this.webGLVersion=1,r=e.getContext("webgl",t)||e.getContext("experimental-webgl",t),!r)throw new Error("This browser does not support WebGL. Try using the canvas renderer");return this.gl=r,this.getExtensions(),this.gl}getExtensions(){const{gl:e}=this,t={anisotropicFiltering:e.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:e.getExtension("OES_texture_float_linear"),s3tc:e.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:e.getExtension("WEBGL_compressed_texture_etc"),etc1:e.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:e.getExtension("WEBGL_compressed_texture_atc"),astc:e.getExtension("WEBGL_compressed_texture_astc")};this.webGLVersion===1?Object.assign(this.extensions,t,{drawBuffers:e.getExtension("WEBGL_draw_buffers"),depthTexture:e.getExtension("WEBGL_depth_texture"),loseContext:e.getExtension("WEBGL_lose_context"),vertexArrayObject:e.getExtension("OES_vertex_array_object")||e.getExtension("MOZ_OES_vertex_array_object")||e.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:e.getExtension("OES_element_index_uint"),floatTexture:e.getExtension("OES_texture_float"),floatTextureLinear:e.getExtension("OES_texture_float_linear"),textureHalfFloat:e.getExtension("OES_texture_half_float"),textureHalfFloatLinear:e.getExtension("OES_texture_half_float_linear")}):this.webGLVersion===2&&Object.assign(this.extensions,t,{colorBufferFloat:e.getExtension("EXT_color_buffer_float")})}handleContextLost(e){e.preventDefault()}handleContextRestored(){this.renderer.runners.contextChange.emit(this.gl)}destroy(){const e=this.renderer.view;this.renderer=null,e.removeEventListener("webglcontextlost",this.handleContextLost),e.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),this.extensions.loseContext&&this.extensions.loseContext.loseContext()}postrender(){this.renderer.objectRenderer.renderingToScreen&&this.gl.flush()}validateContext(e){const t=e.getContextAttributes(),r="WebGL2RenderingContext"in globalThis&&e instanceof globalThis.WebGL2RenderingContext;r&&(this.webGLVersion=2),t&&!t.stencil&&console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");const i=r||!!e.getExtension("OES_element_index_uint");this.supports.uint32Indices=i,i||console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")}}ke.extension={type:_.RendererSystem,name:"context"},T.add(ke);class Nt{constructor(e){this.framebuffer=e,this.stencil=null,this.dirtyId=-1,this.dirtyFormat=-1,this.dirtySize=-1,this.multisample=S.NONE,this.msaaBuffer=null,this.blitFramebuffer=null,this.mipLevel=0}}const Fr=new w;class Ve{constructor(e){this.renderer=e,this.managedFramebuffers=[],this.unknownFramebuffer=new ge(10,10),this.msaaSamples=null}contextChange(){const e=this.gl=this.renderer.gl;if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.current=this.unknownFramebuffer,this.viewport=new w,this.hasMRT=!0,this.writeDepthTexture=!0,this.disposeAll(!0),this.renderer.context.webGLVersion===1){let t=this.renderer.context.extensions.drawBuffers,r=this.renderer.context.extensions.depthTexture;m.PREFER_ENV===z.WEBGL_LEGACY&&(t=null,r=null),t?e.drawBuffers=i=>t.drawBuffersWEBGL(i):(this.hasMRT=!1,e.drawBuffers=()=>{}),r||(this.writeDepthTexture=!1)}else this.msaaSamples=e.getInternalformatParameter(e.RENDERBUFFER,e.RGBA8,e.SAMPLES)}bind(e,t,r=0){const{gl:i}=this;if(e){const n=e.glFramebuffers[this.CONTEXT_UID]||this.initFramebuffer(e);this.current!==e&&(this.current=e,i.bindFramebuffer(i.FRAMEBUFFER,n.framebuffer)),n.mipLevel!==r&&(e.dirtyId++,e.dirtyFormat++,n.mipLevel=r),n.dirtyId!==e.dirtyId&&(n.dirtyId=e.dirtyId,n.dirtyFormat!==e.dirtyFormat?(n.dirtyFormat=e.dirtyFormat,n.dirtySize=e.dirtySize,this.updateFramebuffer(e,r)):n.dirtySize!==e.dirtySize&&(n.dirtySize=e.dirtySize,this.resizeFramebuffer(e)));for(let a=0;a<e.colorTextures.length;a++){const o=e.colorTextures[a];this.renderer.texture.unbind(o.parentTextureArray||o)}if(e.depthTexture&&this.renderer.texture.unbind(e.depthTexture),t){const a=t.width>>r,o=t.height>>r,h=a/t.width;this.setViewport(t.x*h,t.y*h,a,o)}else{const a=e.width>>r,o=e.height>>r;this.setViewport(0,0,a,o)}}else this.current&&(this.current=null,i.bindFramebuffer(i.FRAMEBUFFER,null)),t?this.setViewport(t.x,t.y,t.width,t.height):this.setViewport(0,0,this.renderer.width,this.renderer.height)}setViewport(e,t,r,i){const n=this.viewport;e=Math.round(e),t=Math.round(t),r=Math.round(r),i=Math.round(i),(n.width!==r||n.height!==i||n.x!==e||n.y!==t)&&(n.x=e,n.y=t,n.width=r,n.height=i,this.gl.viewport(e,t,r,i))}get size(){return this.current?{x:0,y:0,width:this.current.width,height:this.current.height}:{x:0,y:0,width:this.renderer.width,height:this.renderer.height}}clear(e,t,r,i,n=_t.COLOR|_t.DEPTH){const{gl:a}=this;a.clearColor(e,t,r,i),a.clear(n)}initFramebuffer(e){const{gl:t}=this,r=new Nt(t.createFramebuffer());return r.multisample=this.detectSamples(e.multisample),e.glFramebuffers[this.CONTEXT_UID]=r,this.managedFramebuffers.push(e),e.disposeRunner.add(this),r}resizeFramebuffer(e){const{gl:t}=this,r=e.glFramebuffers[this.CONTEXT_UID];r.msaaBuffer&&(t.bindRenderbuffer(t.RENDERBUFFER,r.msaaBuffer),t.renderbufferStorageMultisample(t.RENDERBUFFER,r.multisample,t.RGBA8,e.width,e.height)),r.stencil&&(t.bindRenderbuffer(t.RENDERBUFFER,r.stencil),r.msaaBuffer?t.renderbufferStorageMultisample(t.RENDERBUFFER,r.multisample,t.DEPTH24_STENCIL8,e.width,e.height):t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,e.width,e.height));const i=e.colorTextures;let n=i.length;t.drawBuffers||(n=Math.min(n,1));for(let a=0;a<n;a++){const o=i[a],h=o.parentTextureArray||o;this.renderer.texture.bind(h,0)}e.depthTexture&&this.writeDepthTexture&&this.renderer.texture.bind(e.depthTexture,0)}updateFramebuffer(e,t){const{gl:r}=this,i=e.glFramebuffers[this.CONTEXT_UID],n=e.colorTextures;let a=n.length;r.drawBuffers||(a=Math.min(a,1)),i.multisample>1&&this.canMultisampleFramebuffer(e)?(i.msaaBuffer=i.msaaBuffer||r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,i.msaaBuffer),r.renderbufferStorageMultisample(r.RENDERBUFFER,i.multisample,r.RGBA8,e.width,e.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.RENDERBUFFER,i.msaaBuffer)):i.msaaBuffer&&(r.deleteRenderbuffer(i.msaaBuffer),i.msaaBuffer=null,i.blitFramebuffer&&(i.blitFramebuffer.dispose(),i.blitFramebuffer=null));const o=[];for(let h=0;h<a;h++){const u=n[h],l=u.parentTextureArray||u;this.renderer.texture.bind(l,0),!(h===0&&i.msaaBuffer)&&(r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+h,u.target,l._glTextures[this.CONTEXT_UID].texture,t),o.push(r.COLOR_ATTACHMENT0+h))}if(o.length>1&&r.drawBuffers(o),e.depthTexture&&this.writeDepthTexture){const h=e.depthTexture;this.renderer.texture.bind(h,0),r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,h._glTextures[this.CONTEXT_UID].texture,t)}(e.stencil||e.depth)&&!(e.depthTexture&&this.writeDepthTexture)?(i.stencil=i.stencil||r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,i.stencil),i.msaaBuffer?r.renderbufferStorageMultisample(r.RENDERBUFFER,i.multisample,r.DEPTH24_STENCIL8,e.width,e.height):r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_STENCIL,e.width,e.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.RENDERBUFFER,i.stencil)):i.stencil&&(r.deleteRenderbuffer(i.stencil),i.stencil=null)}canMultisampleFramebuffer(e){return this.renderer.context.webGLVersion!==1&&e.colorTextures.length<=1&&!e.depthTexture}detectSamples(e){const{msaaSamples:t}=this;let r=S.NONE;if(e<=1||t===null)return r;for(let i=0;i<t.length;i++)if(t[i]<=e){r=t[i];break}return r===1&&(r=S.NONE),r}blit(e,t,r){const{current:i,renderer:n,gl:a,CONTEXT_UID:o}=this;if(n.context.webGLVersion!==2||!i)return;const h=i.glFramebuffers[o];if(!h)return;if(!e){if(!h.msaaBuffer)return;const l=i.colorTextures[0];if(!l)return;h.blitFramebuffer||(h.blitFramebuffer=new ge(i.width,i.height),h.blitFramebuffer.addColorTexture(0,l)),e=h.blitFramebuffer,e.colorTextures[0]!==l&&(e.colorTextures[0]=l,e.dirtyId++,e.dirtyFormat++),(e.width!==i.width||e.height!==i.height)&&(e.width=i.width,e.height=i.height,e.dirtyId++,e.dirtySize++)}t||(t=Fr,t.width=i.width,t.height=i.height),r||(r=t);const u=t.width===r.width&&t.height===r.height;this.bind(e),a.bindFramebuffer(a.READ_FRAMEBUFFER,h.framebuffer),a.blitFramebuffer(t.left,t.top,t.right,t.bottom,r.left,r.top,r.right,r.bottom,a.COLOR_BUFFER_BIT,u?a.NEAREST:a.LINEAR)}disposeFramebuffer(e,t){const r=e.glFramebuffers[this.CONTEXT_UID],i=this.gl;if(!r)return;delete e.glFramebuffers[this.CONTEXT_UID];const n=this.managedFramebuffers.indexOf(e);n>=0&&this.managedFramebuffers.splice(n,1),e.disposeRunner.remove(this),t||(i.deleteFramebuffer(r.framebuffer),r.msaaBuffer&&i.deleteRenderbuffer(r.msaaBuffer),r.stencil&&i.deleteRenderbuffer(r.stencil)),r.blitFramebuffer&&r.blitFramebuffer.dispose()}disposeAll(e){const t=this.managedFramebuffers;this.managedFramebuffers=[];for(let r=0;r<t.length;r++)this.disposeFramebuffer(t[r],e)}forceStencil(){const e=this.current;if(!e)return;const t=e.glFramebuffers[this.CONTEXT_UID];if(!t||t.stencil)return;e.stencil=!0;const r=e.width,i=e.height,n=this.gl,a=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,a),t.msaaBuffer?n.renderbufferStorageMultisample(n.RENDERBUFFER,t.multisample,n.DEPTH24_STENCIL8,r,i):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,r,i),t.stencil=a,n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,a)}reset(){this.current=this.unknownFramebuffer,this.viewport=new w}destroy(){this.renderer=null}}Ve.extension={type:_.RendererSystem,name:"framebuffer"},T.add(Ve);const He={5126:4,5123:2,5121:1};class $e{constructor(e){this.renderer=e,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this.canUseUInt32ElementIndex=!1,this.managedGeometries={}}contextChange(){this.disposeAll(!0);const e=this.gl=this.renderer.gl,t=this.renderer.context;if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,t.webGLVersion!==2){let r=this.renderer.context.extensions.vertexArrayObject;m.PREFER_ENV===z.WEBGL_LEGACY&&(r=null),r?(e.createVertexArray=()=>r.createVertexArrayOES(),e.bindVertexArray=i=>r.bindVertexArrayOES(i),e.deleteVertexArray=i=>r.deleteVertexArrayOES(i)):(this.hasVao=!1,e.createVertexArray=()=>null,e.bindVertexArray=()=>null,e.deleteVertexArray=()=>null)}if(t.webGLVersion!==2){const r=e.getExtension("ANGLE_instanced_arrays");r?(e.vertexAttribDivisor=(i,n)=>r.vertexAttribDivisorANGLE(i,n),e.drawElementsInstanced=(i,n,a,o,h)=>r.drawElementsInstancedANGLE(i,n,a,o,h),e.drawArraysInstanced=(i,n,a,o)=>r.drawArraysInstancedANGLE(i,n,a,o)):this.hasInstance=!1}this.canUseUInt32ElementIndex=t.webGLVersion===2||!!t.extensions.uint32ElementIndex}bind(e,t){t=t||this.renderer.shader.shader;const{gl:r}=this;let i=e.glVertexArrayObjects[this.CONTEXT_UID],n=!1;i||(this.managedGeometries[e.id]=e,e.disposeRunner.add(this),e.glVertexArrayObjects[this.CONTEXT_UID]=i={},n=!0);const a=i[t.program.id]||this.initGeometryVao(e,t,n);this._activeGeometry=e,this._activeVao!==a&&(this._activeVao=a,this.hasVao?r.bindVertexArray(a):this.activateVao(e,t.program)),this.updateBuffers()}reset(){this.unbind()}updateBuffers(){const e=this._activeGeometry,t=this.renderer.buffer;for(let r=0;r<e.buffers.length;r++){const i=e.buffers[r];t.update(i)}}checkCompatibility(e,t){const r=e.attributes,i=t.attributeData;for(const n in i)if(!r[n])throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)}getSignature(e,t){const r=e.attributes,i=t.attributeData,n=["g",e.id];for(const a in r)i[a]&&n.push(a,i[a].location);return n.join("-")}initGeometryVao(e,t,r=!0){const i=this.gl,n=this.CONTEXT_UID,a=this.renderer.buffer,o=t.program;o.glPrograms[n]||this.renderer.shader.generateProgram(t),this.checkCompatibility(e,o);const h=this.getSignature(e,o),u=e.glVertexArrayObjects[this.CONTEXT_UID];let l=u[h];if(l)return u[o.id]=l,l;const d=e.buffers,f=e.attributes,p={},b={};for(const v in d)p[v]=0,b[v]=0;for(const v in f)!f[v].size&&o.attributeData[v]?f[v].size=o.attributeData[v].size:f[v].size||console.warn(`PIXI Geometry attribute '${v}' size cannot be determined (likely the bound shader does not have the attribute)`),p[f[v].buffer]+=f[v].size*He[f[v].type];for(const v in f){const I=f[v],gt=I.size;I.stride===void 0&&(p[I.buffer]===gt*He[I.type]?I.stride=0:I.stride=p[I.buffer]),I.start===void 0&&(I.start=b[I.buffer],b[I.buffer]+=gt*He[I.type])}l=i.createVertexArray(),i.bindVertexArray(l);for(let v=0;v<d.length;v++){const I=d[v];a.bind(I),r&&I._glBuffers[n].refCount++}return this.activateVao(e,o),this._activeVao=l,u[o.id]=l,u[h]=l,l}disposeGeometry(e,t){if(!this.managedGeometries[e.id])return;delete this.managedGeometries[e.id];const r=e.glVertexArrayObjects[this.CONTEXT_UID],i=this.gl,n=e.buffers,a=this.renderer?.buffer;if(e.disposeRunner.remove(this),!!r){if(a)for(let o=0;o<n.length;o++){const h=n[o]._glBuffers[this.CONTEXT_UID];h&&(h.refCount--,h.refCount===0&&!t&&a.dispose(n[o],t))}if(!t){for(const o in r)if(o[0]==="g"){const h=r[o];this._activeVao===h&&this.unbind(),i.deleteVertexArray(h)}}delete e.glVertexArrayObjects[this.CONTEXT_UID]}}disposeAll(e){const t=Object.keys(this.managedGeometries);for(let r=0;r<t.length;r++)this.disposeGeometry(this.managedGeometries[t[r]],e)}activateVao(e,t){const r=this.gl,i=this.CONTEXT_UID,n=this.renderer.buffer,a=e.buffers,o=e.attributes;e.indexBuffer&&n.bind(e.indexBuffer);let h=null;for(const u in o){const l=o[u],d=a[l.buffer],f=d._glBuffers[i];if(t.attributeData[u]){h!==f&&(n.bind(d),h=f);const p=t.attributeData[u].location;if(r.enableVertexAttribArray(p),r.vertexAttribPointer(p,l.size,l.type||r.FLOAT,l.normalized,l.stride,l.start),l.instance)if(this.hasInstance)r.vertexAttribDivisor(p,1);else throw new Error("geometry error, GPU Instancing is not supported on this device")}}}draw(e,t,r,i){const{gl:n}=this,a=this._activeGeometry;if(a.indexBuffer){const o=a.indexBuffer.data.BYTES_PER_ELEMENT,h=o===2?n.UNSIGNED_SHORT:n.UNSIGNED_INT;o===2||o===4&&this.canUseUInt32ElementIndex?a.instanced?n.drawElementsInstanced(e,t||a.indexBuffer.data.length,h,(r||0)*o,i||1):n.drawElements(e,t||a.indexBuffer.data.length,h,(r||0)*o):console.warn("unsupported index buffer type: uint32")}else a.instanced?n.drawArraysInstanced(e,r,t||a.getSize(),i||1):n.drawArrays(e,r,t||a.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this.renderer=null}}$e.extension={type:_.RendererSystem,name:"geometry"},T.add($e);class Ot{constructor(e=null){this.type=R.NONE,this.autoDetect=!0,this.maskObject=e||null,this.pooled=!1,this.isMaskData=!0,this.resolution=null,this.multisample=m.FILTER_MULTISAMPLE,this.enabled=!0,this.colorMask=15,this._filters=null,this._stencilCounter=0,this._scissorCounter=0,this._scissorRect=null,this._scissorRectLocal=null,this._colorMask=15,this._target=null}get filter(){return this._filters?this._filters[0]:null}set filter(e){e?this._filters?this._filters[0]=e:this._filters=[e]:this._filters=null}reset(){this.pooled&&(this.maskObject=null,this.type=R.NONE,this.autoDetect=!0),this._target=null,this._scissorRectLocal=null}copyCountersOrReset(e){e?(this._stencilCounter=e._stencilCounter,this._scissorCounter=e._scissorCounter,this._scissorRect=e._scissorRect):(this._stencilCounter=0,this._scissorCounter=0,this._scissorRect=null)}}function Pt(s,e,t){const r=s.createShader(e);return s.shaderSource(r,t),s.compileShader(r),r}function Ut(s,e){const t=s.getShaderSource(e).split(`
`).map((u,l)=>`${l}: ${u}`),r=s.getShaderInfoLog(e),i=r.split(`
`),n={},a=i.map(u=>parseFloat(u.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))).filter(u=>u&&!n[u]?(n[u]=!0,!0):!1),o=[""];a.forEach(u=>{t[u-1]=`%c${t[u-1]}%c`,o.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});const h=t.join(`
`);o[0]=h,console.error(r),console.groupCollapsed("click to view full shader code"),console.warn(...o),console.groupEnd()}function Mr(s,e,t,r){s.getProgramParameter(e,s.LINK_STATUS)||(s.getShaderParameter(t,s.COMPILE_STATUS)||Ut(s,t),s.getShaderParameter(r,s.COMPILE_STATUS)||Ut(s,r),console.error("PixiJS Error: Could not initialize shader."),s.getProgramInfoLog(e)!==""&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",s.getProgramInfoLog(e)))}function Xe(s){const e=new Array(s);for(let t=0;t<e.length;t++)e[t]=!1;return e}function Dt(s,e){switch(s){case"float":return 0;case"vec2":return new Float32Array(2*e);case"vec3":return new Float32Array(3*e);case"vec4":return new Float32Array(4*e);case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"ivec2":return new Int32Array(2*e);case"ivec3":return new Int32Array(3*e);case"ivec4":return new Int32Array(4*e);case"uvec2":return new Uint32Array(2*e);case"uvec3":return new Uint32Array(3*e);case"uvec4":return new Uint32Array(4*e);case"bool":return!1;case"bvec2":return Xe(2*e);case"bvec3":return Xe(3*e);case"bvec4":return Xe(4*e);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const Lt={};let ve=Lt;function Gt(){if(ve===Lt||ve?.isContextLost()){const s=m.ADAPTER.createCanvas();let e;m.PREFER_ENV>=z.WEBGL2&&(e=s.getContext("webgl2",{})),e||(e=s.getContext("webgl",{})||s.getContext("experimental-webgl",{}),e?e.getExtension("WEBGL_draw_buffers"):e=null),ve=e}return ve}let Ee;function Br(){if(!Ee){Ee=P.MEDIUM;const s=Gt();s&&s.getShaderPrecisionFormat&&(Ee=s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision?P.HIGH:P.MEDIUM)}return Ee}function kt(s,e,t){if(s.substring(0,9)!=="precision"){let r=e;return e===P.HIGH&&t!==P.HIGH&&(r=P.MEDIUM),`precision ${r} float;
${s}`}else if(t!==P.HIGH&&s.substring(0,15)==="precision highp")return s.replace("precision highp","precision mediump");return s}const Nr={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,uint:1,uvec2:2,uvec3:3,uvec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1};function Vt(s){return Nr[s]}let Te=null;const Ht={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"};function $t(s,e){if(!Te){const t=Object.keys(Ht);Te={};for(let r=0;r<t.length;++r){const i=t[r];Te[s[i]]=Ht[i]}}return Te[e]}const k=[{test:s=>s.type==="float"&&s.size===1&&!s.isArray,code:s=>`
            if(uv["${s}"] !== ud["${s}"].value)
            {
                ud["${s}"].value = uv["${s}"]
                gl.uniform1f(ud["${s}"].location, uv["${s}"])
            }
            `},{test:(s,e)=>(s.type==="sampler2D"||s.type==="samplerCube"||s.type==="sampler2DArray")&&s.size===1&&!s.isArray&&(e==null||e.castToBaseTexture!==void 0),code:s=>`t = syncData.textureCount++;

            renderer.texture.bind(uv["${s}"], t);

            if(ud["${s}"].value !== t)
            {
                ud["${s}"].value = t;
                gl.uniform1i(ud["${s}"].location, t);
; // eslint-disable-line max-len
            }`},{test:(s,e)=>s.type==="mat3"&&s.size===1&&!s.isArray&&e.a!==void 0,code:s=>`
            gl.uniformMatrix3fv(ud["${s}"].location, false, uv["${s}"].toArray(true));
            `,codeUbo:s=>`
                var ${s}_matrix = uv.${s}.toArray(true);

                data[offset] = ${s}_matrix[0];
                data[offset+1] = ${s}_matrix[1];
                data[offset+2] = ${s}_matrix[2];
        
                data[offset + 4] = ${s}_matrix[3];
                data[offset + 5] = ${s}_matrix[4];
                data[offset + 6] = ${s}_matrix[5];
        
                data[offset + 8] = ${s}_matrix[6];
                data[offset + 9] = ${s}_matrix[7];
                data[offset + 10] = ${s}_matrix[8];
            `},{test:(s,e)=>s.type==="vec2"&&s.size===1&&!s.isArray&&e.x!==void 0,code:s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${s}"].location, v.x, v.y);
                }`,codeUbo:s=>`
                v = uv.${s};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `},{test:s=>s.type==="vec2"&&s.size===1&&!s.isArray,code:s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${s}"].location, v[0], v[1]);
                }
            `},{test:(s,e)=>s.type==="vec4"&&s.size===1&&!s.isArray&&e.width!==void 0,code:s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${s}"].location, v.x, v.y, v.width, v.height)
                }`,codeUbo:s=>`
                    v = uv.${s};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `},{test:s=>s.type==="vec4"&&s.size===1&&!s.isArray,code:s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${s}"].location, v[0], v[1], v[2], v[3])
                }`}],Or={float:`
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,vec2:`
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,vec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,vec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,int:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,ivec2:`
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,ivec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,ivec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,uint:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,uvec2:`
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,uvec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,uvec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,bool:`
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,bvec2:`
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,bvec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,bvec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,mat2:"gl.uniformMatrix2fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",sampler2D:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,samplerCube:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,sampler2DArray:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`},Pr={float:"gl.uniform1fv(location, v)",vec2:"gl.uniform2fv(location, v)",vec3:"gl.uniform3fv(location, v)",vec4:"gl.uniform4fv(location, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat2:"gl.uniformMatrix2fv(location, false, v)",int:"gl.uniform1iv(location, v)",ivec2:"gl.uniform2iv(location, v)",ivec3:"gl.uniform3iv(location, v)",ivec4:"gl.uniform4iv(location, v)",uint:"gl.uniform1uiv(location, v)",uvec2:"gl.uniform2uiv(location, v)",uvec3:"gl.uniform3uiv(location, v)",uvec4:"gl.uniform4uiv(location, v)",bool:"gl.uniform1iv(location, v)",bvec2:"gl.uniform2iv(location, v)",bvec3:"gl.uniform3iv(location, v)",bvec4:"gl.uniform4iv(location, v)",sampler2D:"gl.uniform1iv(location, v)",samplerCube:"gl.uniform1iv(location, v)",sampler2DArray:"gl.uniform1iv(location, v)"};function Ur(s,e){const t=[`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];for(const r in s.uniforms){const i=e[r];if(!i){s.uniforms[r]?.group&&(s.uniforms[r].ubo?t.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${r}, '${r}');
                    `):t.push(`
                        renderer.shader.syncUniformGroup(uv.${r}, syncData);
                    `));continue}const n=s.uniforms[r];let a=!1;for(let o=0;o<k.length;o++)if(k[o].test(i,n)){t.push(k[o].code(r,n)),a=!0;break}if(!a){const o=(i.size===1&&!i.isArray?Or:Pr)[i.type].replace("location",`ud["${r}"].location`);t.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${o};`)}}return new Function("ud","uv","renderer","syncData",t.join(`
`))}const Dr=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join(`
`);function Lr(s){let e="";for(let t=0;t<s;++t)t>0&&(e+=`
else `),t<s-1&&(e+=`if(test == ${t}.0){}`);return e}function Xt(s,e){if(s===0)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const t=e.createShader(e.FRAGMENT_SHADER);for(;;){const r=Dr.replace(/%forloop%/gi,Lr(s));if(e.shaderSource(t,r),e.compileShader(t),!e.getShaderParameter(t,e.COMPILE_STATUS))s=s/2|0;else break}return s}let se;function Gr(){if(typeof se=="boolean")return se;try{se=new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")===!0}catch{se=!1}return se}var kr=`varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,Vr=`attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;let Hr=0;const be={};class U{constructor(e,t,r="pixi-shader"){this.id=Hr++,this.vertexSrc=e||U.defaultVertexSrc,this.fragmentSrc=t||U.defaultFragmentSrc,this.vertexSrc=this.vertexSrc.trim(),this.fragmentSrc=this.fragmentSrc.trim(),this.vertexSrc.substring(0,8)!=="#version"&&(r=r.replace(/\s+/g,"-"),be[r]?(be[r]++,r+=`-${be[r]}`):be[r]=1,this.vertexSrc=`#define SHADER_NAME ${r}
${this.vertexSrc}`,this.fragmentSrc=`#define SHADER_NAME ${r}
${this.fragmentSrc}`,this.vertexSrc=kt(this.vertexSrc,m.PRECISION_VERTEX,P.HIGH),this.fragmentSrc=kt(this.fragmentSrc,m.PRECISION_FRAGMENT,Br())),this.glPrograms={},this.syncUniforms=null}static get defaultVertexSrc(){return Vr}static get defaultFragmentSrc(){return kr}static from(e,t,r){const i=e+t;let n=bt[i];return n||(bt[i]=n=new U(e,t,r)),n}}class he{constructor(e,t){this.uniformBindCount=0,this.program=e,t?t instanceof F?this.uniformGroup=t:this.uniformGroup=new F(t):this.uniformGroup=new F({})}checkUniformExists(e,t){if(t.uniforms[e])return!0;for(const r in t.uniforms){const i=t.uniforms[r];if(i.group&&this.checkUniformExists(e,i))return!0}return!1}destroy(){this.uniformGroup=null}get uniforms(){return this.uniformGroup.uniforms}static from(e,t,r){const i=U.from(e,t);return new he(i,r)}}const ze=0,je=1,We=2,Ye=3,Ke=4,qe=5;class Z{constructor(){this.data=0,this.blendMode=g.NORMAL,this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<ze)}set blend(e){!!(this.data&1<<ze)!==e&&(this.data^=1<<ze)}get offsets(){return!!(this.data&1<<je)}set offsets(e){!!(this.data&1<<je)!==e&&(this.data^=1<<je)}get culling(){return!!(this.data&1<<We)}set culling(e){!!(this.data&1<<We)!==e&&(this.data^=1<<We)}get depthTest(){return!!(this.data&1<<Ye)}set depthTest(e){!!(this.data&1<<Ye)!==e&&(this.data^=1<<Ye)}get depthMask(){return!!(this.data&1<<qe)}set depthMask(e){!!(this.data&1<<qe)!==e&&(this.data^=1<<qe)}get clockwiseFrontFace(){return!!(this.data&1<<Ke)}set clockwiseFrontFace(e){!!(this.data&1<<Ke)!==e&&(this.data^=1<<Ke)}get blendMode(){return this._blendMode}set blendMode(e){this.blend=e!==g.NONE,this._blendMode=e}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}static for2d(){const e=new Z;return e.depthTest=!1,e.blend=!0,e}}var $r=`varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,Xr=`attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;class ue extends he{constructor(e,t,r){const i=U.from(e||ue.defaultVertexSrc,t||ue.defaultFragmentSrc);super(i,r),this.padding=0,this.resolution=m.FILTER_RESOLUTION,this.multisample=m.FILTER_MULTISAMPLE,this.enabled=!0,this.autoFit=!0,this.state=new Z}apply(e,t,r,i,n){e.applyFilter(this,t,r,i)}get blendMode(){return this.state.blendMode}set blendMode(e){this.state.blendMode=e}get resolution(){return this._resolution}set resolution(e){this._resolution=e}static get defaultVertexSrc(){return Xr}static get defaultFragmentSrc(){return $r}}var zr=`attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`,jr=`varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`;const zt=new M;class jt{constructor(e,t){this._texture=e,this.mapCoord=new M,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,this.clampMargin=typeof t>"u"?.5:t,this.isSimple=!1}get texture(){return this._texture}set texture(e){this._texture=e,this._textureID=-1}multiplyUvs(e,t){t===void 0&&(t=e);const r=this.mapCoord;for(let i=0;i<e.length;i+=2){const n=e[i],a=e[i+1];t[i]=n*r.a+a*r.c+r.tx,t[i+1]=n*r.b+a*r.d+r.ty}return t}update(e){const t=this._texture;if(!t||!t.valid||!e&&this._textureID===t._updateID)return!1;this._textureID=t._updateID,this._updateID++;const r=t._uvs;this.mapCoord.set(r.x1-r.x0,r.y1-r.y0,r.x3-r.x0,r.y3-r.y0,r.x0,r.y0);const i=t.orig,n=t.trim;n&&(zt.set(i.width/n.width,0,0,i.height/n.height,-n.x/n.width,-n.y/n.height),this.mapCoord.append(zt));const a=t.baseTexture,o=this.uClampFrame,h=this.clampMargin/a.resolution,u=this.clampOffset;return o[0]=(t._frame.x+h+u)/a.width,o[1]=(t._frame.y+h+u)/a.height,o[2]=(t._frame.x+t._frame.width-h+u)/a.width,o[3]=(t._frame.y+t._frame.height-h+u)/a.height,this.uClampOffset[0]=u/a.realWidth,this.uClampOffset[1]=u/a.realHeight,this.isSimple=t._frame.width===a.width&&t._frame.height===a.height&&t.rotate===0,!0}}class Wt extends ue{constructor(e,t,r){let i=null;typeof e!="string"&&t===void 0&&r===void 0&&(i=e,e=void 0,t=void 0,r=void 0),super(e||zr,t||jr,r),this.maskSprite=i,this.maskMatrix=new M}get maskSprite(){return this._maskSprite}set maskSprite(e){this._maskSprite=e,this._maskSprite&&(this._maskSprite.renderable=!1)}apply(e,t,r,i){const n=this._maskSprite,a=n._texture;!a.valid||(a.uvMatrix||(a.uvMatrix=new jt(a,0)),a.uvMatrix.update(),this.uniforms.npmAlpha=a.baseTexture.alphaMode?0:1,this.uniforms.mask=a,this.uniforms.otherMatrix=e.calculateSpriteMatrix(this.maskMatrix,n).prepend(a.uvMatrix.mapCoord),this.uniforms.alpha=n.worldAlpha,this.uniforms.maskClamp=a.uvMatrix.uClampFrame,e.applyFilter(this,t,r,i))}}class Ze{constructor(e){this.renderer=e,this.enableScissor=!0,this.alphaMaskPool=[],this.maskDataPool=[],this.maskStack=[],this.alphaMaskIndex=0}setMaskStack(e){this.maskStack=e,this.renderer.scissor.setMaskStack(e),this.renderer.stencil.setMaskStack(e)}push(e,t){let r=t;if(!r.isMaskData){const n=this.maskDataPool.pop()||new Ot;n.pooled=!0,n.maskObject=t,r=n}const i=this.maskStack.length!==0?this.maskStack[this.maskStack.length-1]:null;if(r.copyCountersOrReset(i),r._colorMask=i?i._colorMask:15,r.autoDetect&&this.detect(r),r._target=e,r.type!==R.SPRITE&&this.maskStack.push(r),r.enabled)switch(r.type){case R.SCISSOR:this.renderer.scissor.push(r);break;case R.STENCIL:this.renderer.stencil.push(r);break;case R.SPRITE:r.copyCountersOrReset(null),this.pushSpriteMask(r);break;case R.COLOR:this.pushColorMask(r);break}r.type===R.SPRITE&&this.maskStack.push(r)}pop(e){const t=this.maskStack.pop();if(!(!t||t._target!==e)){if(t.enabled)switch(t.type){case R.SCISSOR:this.renderer.scissor.pop(t);break;case R.STENCIL:this.renderer.stencil.pop(t.maskObject);break;case R.SPRITE:this.popSpriteMask(t);break;case R.COLOR:this.popColorMask(t);break}if(t.reset(),t.pooled&&this.maskDataPool.push(t),this.maskStack.length!==0){const r=this.maskStack[this.maskStack.length-1];r.type===R.SPRITE&&r._filters&&(r._filters[0].maskSprite=r.maskObject)}}}detect(e){const t=e.maskObject;t?t.isSprite?e.type=R.SPRITE:this.enableScissor&&this.renderer.scissor.testScissor(e)?e.type=R.SCISSOR:e.type=R.STENCIL:e.type=R.COLOR}pushSpriteMask(e){const{maskObject:t}=e,r=e._target;let i=e._filters;i||(i=this.alphaMaskPool[this.alphaMaskIndex],i||(i=this.alphaMaskPool[this.alphaMaskIndex]=[new Wt]));const n=this.renderer,a=n.renderTexture;let o,h;if(a.current){const l=a.current;o=e.resolution||l.resolution,h=e.multisample??l.multisample}else o=e.resolution||n.resolution,h=e.multisample??n.multisample;i[0].resolution=o,i[0].multisample=h,i[0].maskSprite=t;const u=r.filterArea;r.filterArea=t.getBounds(!0),n.filter.push(r,i),r.filterArea=u,e._filters||this.alphaMaskIndex++}popSpriteMask(e){this.renderer.filter.pop(),e._filters?e._filters[0].maskSprite=null:(this.alphaMaskIndex--,this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite=null)}pushColorMask(e){const t=e._colorMask,r=e._colorMask=t&e.colorMask;r!==t&&this.renderer.gl.colorMask((r&1)!==0,(r&2)!==0,(r&4)!==0,(r&8)!==0)}popColorMask(e){const t=e._colorMask,r=this.maskStack.length>0?this.maskStack[this.maskStack.length-1]._colorMask:15;r!==t&&this.renderer.gl.colorMask((r&1)!==0,(r&2)!==0,(r&4)!==0,(r&8)!==0)}destroy(){this.renderer=null}}Ze.extension={type:_.RendererSystem,name:"mask"},T.add(Ze);class Yt{constructor(e){this.renderer=e,this.maskStack=[],this.glConst=0}getStackLength(){return this.maskStack.length}setMaskStack(e){const{gl:t}=this.renderer,r=this.getStackLength();this.maskStack=e;const i=this.getStackLength();i!==r&&(i===0?t.disable(this.glConst):(t.enable(this.glConst),this._useCurrent()))}_useCurrent(){}destroy(){this.renderer=null,this.maskStack=null}}const Kt=new M,qt=[],ye=class extends Yt{constructor(s){super(s),this.glConst=m.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST}getStackLength(){const s=this.maskStack[this.maskStack.length-1];return s?s._scissorCounter:0}calcScissorRect(s){if(s._scissorRectLocal)return;const e=s._scissorRect,{maskObject:t}=s,{renderer:r}=this,i=r.renderTexture,n=t.getBounds(!0,qt.pop()??new w);this.roundFrameToPixels(n,i.current?i.current.resolution:r.resolution,i.sourceFrame,i.destinationFrame,r.projection.transform),e&&n.fit(e),s._scissorRectLocal=n}static isMatrixRotated(s){if(!s)return!1;const{a:e,b:t,c:r,d:i}=s;return(Math.abs(t)>1e-4||Math.abs(r)>1e-4)&&(Math.abs(e)>1e-4||Math.abs(i)>1e-4)}testScissor(s){const{maskObject:e}=s;if(!e.isFastRect||!e.isFastRect()||ye.isMatrixRotated(e.worldTransform)||ye.isMatrixRotated(this.renderer.projection.transform))return!1;this.calcScissorRect(s);const t=s._scissorRectLocal;return t.width>0&&t.height>0}roundFrameToPixels(s,e,t,r,i){ye.isMatrixRotated(i)||(i=i?Kt.copyFrom(i):Kt.identity(),i.translate(-t.x,-t.y).scale(r.width/t.width,r.height/t.height).translate(r.x,r.y),this.renderer.filter.transformAABB(i,s),s.fit(r),s.x=Math.round(s.x*e),s.y=Math.round(s.y*e),s.width=Math.round(s.width*e),s.height=Math.round(s.height*e))}push(s){s._scissorRectLocal||this.calcScissorRect(s);const{gl:e}=this.renderer;s._scissorRect||e.enable(e.SCISSOR_TEST),s._scissorCounter++,s._scissorRect=s._scissorRectLocal,this._useCurrent()}pop(s){const{gl:e}=this.renderer;s&&qt.push(s._scissorRectLocal),this.getStackLength()>0?this._useCurrent():e.disable(e.SCISSOR_TEST)}_useCurrent(){const s=this.maskStack[this.maskStack.length-1]._scissorRect;let e;this.renderer.renderTexture.current?e=s.y:e=this.renderer.height-s.height-s.y,this.renderer.gl.scissor(s.x,e,s.width,s.height)}};let Qe=ye;Qe.extension={type:_.RendererSystem,name:"scissor"},T.add(Qe);class Je extends Yt{constructor(e){super(e),this.glConst=m.ADAPTER.getWebGLRenderingContext().STENCIL_TEST}getStackLength(){const e=this.maskStack[this.maskStack.length-1];return e?e._stencilCounter:0}push(e){const t=e.maskObject,{gl:r}=this.renderer,i=e._stencilCounter;i===0&&(this.renderer.framebuffer.forceStencil(),r.clearStencil(0),r.clear(r.STENCIL_BUFFER_BIT),r.enable(r.STENCIL_TEST)),e._stencilCounter++;const n=e._colorMask;n!==0&&(e._colorMask=0,r.colorMask(!1,!1,!1,!1)),r.stencilFunc(r.EQUAL,i,4294967295),r.stencilOp(r.KEEP,r.KEEP,r.INCR),t.renderable=!0,t.render(this.renderer),this.renderer.batch.flush(),t.renderable=!1,n!==0&&(e._colorMask=n,r.colorMask((n&1)!==0,(n&2)!==0,(n&4)!==0,(n&8)!==0)),this._useCurrent()}pop(e){const t=this.renderer.gl;if(this.getStackLength()===0)t.disable(t.STENCIL_TEST);else{const r=this.maskStack.length!==0?this.maskStack[this.maskStack.length-1]:null,i=r?r._colorMask:15;i!==0&&(r._colorMask=0,t.colorMask(!1,!1,!1,!1)),t.stencilOp(t.KEEP,t.KEEP,t.DECR),e.renderable=!0,e.render(this.renderer),this.renderer.batch.flush(),e.renderable=!1,i!==0&&(r._colorMask=i,t.colorMask((i&1)!==0,(i&2)!==0,(i&4)!==0,(i&8)!==0)),this._useCurrent()}}_useCurrent(){const e=this.renderer.gl;e.stencilFunc(e.EQUAL,this.getStackLength(),4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP)}}Je.extension={type:_.RendererSystem,name:"stencil"},T.add(Je);class et{constructor(e){this.renderer=e,this.destinationFrame=null,this.sourceFrame=null,this.defaultFrame=null,this.projectionMatrix=new M,this.transform=null}update(e,t,r,i){this.destinationFrame=e||this.destinationFrame||this.defaultFrame,this.sourceFrame=t||this.sourceFrame||e,this.calculateProjection(this.destinationFrame,this.sourceFrame,r,i),this.transform&&this.projectionMatrix.append(this.transform);const n=this.renderer;n.globalUniforms.uniforms.projectionMatrix=this.projectionMatrix,n.globalUniforms.update(),n.shader.shader&&n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)}calculateProjection(e,t,r,i){const n=this.projectionMatrix,a=i?-1:1;n.identity(),n.a=1/t.width*2,n.d=a*(1/t.height*2),n.tx=-1-t.x*n.a,n.ty=-a-t.y*n.d}setTransform(e){}destroy(){this.renderer=null}}et.extension={type:_.RendererSystem,name:"projection"},T.add(et);const V=new w,ie=new w;class tt{constructor(e){this.renderer=e,this.defaultMaskStack=[],this.current=null,this.sourceFrame=new w,this.destinationFrame=new w,this.viewportFrame=new w}bind(e=null,t,r){const i=this.renderer;this.current=e;let n,a,o;e?(n=e.baseTexture,o=n.resolution,t||(V.width=e.frame.width,V.height=e.frame.height,t=V),r||(ie.x=e.frame.x,ie.y=e.frame.y,ie.width=t.width,ie.height=t.height,r=ie),a=n.framebuffer):(o=i.resolution,t||(V.width=i._view.screen.width,V.height=i._view.screen.height,t=V),r||(r=V,r.width=t.width,r.height=t.height));const h=this.viewportFrame;h.x=r.x*o,h.y=r.y*o,h.width=r.width*o,h.height=r.height*o,e||(h.y=i.view.height-(h.y+h.height)),h.ceil(),this.renderer.framebuffer.bind(a,h),this.renderer.projection.update(r,t,o,!a),e?this.renderer.mask.setMaskStack(n.maskStack):this.renderer.mask.setMaskStack(this.defaultMaskStack),this.sourceFrame.copyFrom(t),this.destinationFrame.copyFrom(r)}clear(e,t){this.current?e=e||this.current.baseTexture.clearColor:e=e||this.renderer.background.colorRgba;const r=this.destinationFrame,i=this.current?this.current.baseTexture:this.renderer._view.screen,n=r.width!==i.width||r.height!==i.height;if(n){let{x:a,y:o,width:h,height:u}=this.viewportFrame;a=Math.round(a),o=Math.round(o),h=Math.round(h),u=Math.round(u),this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),this.renderer.gl.scissor(a,o,h,u)}this.renderer.framebuffer.clear(e[0],e[1],e[2],e[3],t),n&&this.renderer.scissor.pop()}resize(){this.bind(null)}reset(){this.bind(null)}destroy(){this.renderer=null}}tt.extension={type:_.RendererSystem,name:"renderTexture"},T.add(tt);function Wr(s,e,t,r,i){t.buffer.update(i)}const Yr={float:`
        data[offset] = v;
    `,vec2:`
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,vec3:`
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,vec4:`
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,mat2:`
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,mat3:`
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,mat4:`
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `},Zt={float:4,vec2:8,vec3:12,vec4:16,int:4,ivec2:8,ivec3:12,ivec4:16,uint:4,uvec2:8,uvec3:12,uvec4:16,bool:4,bvec2:8,bvec3:12,bvec4:16,mat2:16*2,mat3:16*3,mat4:16*4};function Qt(s){const e=s.map(n=>({data:n,offset:0,dataLen:0,dirty:0}));let t=0,r=0,i=0;for(let n=0;n<e.length;n++){const a=e[n];if(t=Zt[a.data.type],a.data.size>1&&(t=Math.max(t,16)*a.data.size),a.dataLen=t,r%t!==0&&r<16){const o=r%t%16;r+=o,i+=o}r+t>16?(i=Math.ceil(i/16)*16,a.offset=i,i+=t,r=t):(a.offset=i,r+=t,i+=t)}return i=Math.ceil(i/16)*16,{uboElements:e,size:i}}function Jt(s,e){const t=[];for(const r in s)e[r]&&t.push(e[r]);return t.sort((r,i)=>r.index-i.index),t}function er(s,e){if(!s.autoManage)return{size:0,syncFunc:Wr};const t=Jt(s.uniforms,e),{uboElements:r,size:i}=Qt(t),n=[`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];for(let a=0;a<r.length;a++){const o=r[a],h=s.uniforms[o.data.name],u=o.data.name;let l=!1;for(let d=0;d<k.length;d++){const f=k[d];if(f.codeUbo&&f.test(o.data,h)){n.push(`offset = ${o.offset/4};`,k[d].codeUbo(o.data.name,h)),l=!0;break}}if(!l)if(o.data.size>1){const d=Vt(o.data.type),f=Math.max(Zt[o.data.type]/16,1),p=d/f,b=(4-p%4)%4;n.push(`
                cv = ud.${u}.value;
                v = uv.${u};
                offset = ${o.offset/4};

                t = 0;

                for(var i=0; i < ${o.data.size*f}; i++)
                {
                    for(var j = 0; j < ${p}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${b};
                }

                `)}else{const d=Yr[o.data.type];n.push(`
                cv = ud.${u}.value;
                v = uv.${u};
                offset = ${o.offset/4};
                ${d};
                `)}}return n.push(`
       renderer.buffer.update(buffer);
    `),{size:i,syncFunc:new Function("ud","uv","renderer","syncData","buffer",n.join(`
`))}}class Kr{}class tr{constructor(e,t){this.program=e,this.uniformData=t,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBufferBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBufferBindings=null,this.program=null}}function qr(s,e){const t={},r=e.getProgramParameter(s,e.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const n=e.getActiveAttrib(s,i);if(n.name.startsWith("gl_"))continue;const a=$t(e,n.type),o={type:a,name:n.name,size:Vt(a),location:e.getAttribLocation(s,n.name)};t[n.name]=o}return t}function Zr(s,e){const t={},r=e.getProgramParameter(s,e.ACTIVE_UNIFORMS);for(let i=0;i<r;i++){const n=e.getActiveUniform(s,i),a=n.name.replace(/\[.*?\]$/,""),o=!!n.name.match(/\[.*?\]$/),h=$t(e,n.type);t[a]={name:a,index:i,type:h,size:n.size,isArray:o,value:Dt(h,n.size)}}return t}function rr(s,e){const t=Pt(s,s.VERTEX_SHADER,e.vertexSrc),r=Pt(s,s.FRAGMENT_SHADER,e.fragmentSrc),i=s.createProgram();if(s.attachShader(i,t),s.attachShader(i,r),s.linkProgram(i),s.getProgramParameter(i,s.LINK_STATUS)||Mr(s,i,t,r),e.attributeData=qr(i,s),e.uniformData=Zr(i,s),!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)){const a=Object.keys(e.attributeData);a.sort((o,h)=>o>h?1:-1);for(let o=0;o<a.length;o++)e.attributeData[a[o]].location=o,s.bindAttribLocation(i,o,a[o]);s.linkProgram(i)}s.deleteShader(t),s.deleteShader(r);const n={};for(const a in e.uniformData){const o=e.uniformData[a];n[a]={location:s.getUniformLocation(i,a),value:Dt(o.type,o.size)}}return new tr(i,n)}let Qr=0;const Se={textureCount:0,uboCount:0};class rt{constructor(e){this.destroyed=!1,this.renderer=e,this.systemCheck(),this.gl=null,this.shader=null,this.program=null,this.cache={},this._uboCache={},this.id=Qr++}systemCheck(){if(!Gr())throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")}contextChange(e){this.gl=e,this.reset()}bind(e,t){e.uniforms.globals=this.renderer.globalUniforms;const r=e.program,i=r.glPrograms[this.renderer.CONTEXT_UID]||this.generateProgram(e);return this.shader=e,this.program!==r&&(this.program=r,this.gl.useProgram(i.program)),t||(Se.textureCount=0,Se.uboCount=0,this.syncUniformGroup(e.uniformGroup,Se)),i}setUniforms(e){const t=this.shader.program,r=t.glPrograms[this.renderer.CONTEXT_UID];t.syncUniforms(r.uniformData,e,this.renderer)}syncUniformGroup(e,t){const r=this.getGlProgram();(!e.static||e.dirtyId!==r.uniformDirtyGroups[e.id])&&(r.uniformDirtyGroups[e.id]=e.dirtyId,this.syncUniforms(e,r,t))}syncUniforms(e,t,r){(e.syncUniforms[this.shader.program.id]||this.createSyncGroups(e))(t.uniformData,e.uniforms,this.renderer,r)}createSyncGroups(e){const t=this.getSignature(e,this.shader.program.uniformData,"u");return this.cache[t]||(this.cache[t]=Ur(e,this.shader.program.uniformData)),e.syncUniforms[this.shader.program.id]=this.cache[t],e.syncUniforms[this.shader.program.id]}syncUniformBufferGroup(e,t){const r=this.getGlProgram();if(!e.static||e.dirtyId!==0||!r.uniformGroups[e.id]){e.dirtyId=0;const i=r.uniformGroups[e.id]||this.createSyncBufferGroup(e,r,t);e.buffer.update(),i(r.uniformData,e.uniforms,this.renderer,Se,e.buffer)}this.renderer.buffer.bindBufferBase(e.buffer,r.uniformBufferBindings[t])}createSyncBufferGroup(e,t,r){const{gl:i}=this.renderer;this.renderer.buffer.bind(e.buffer);const n=this.gl.getUniformBlockIndex(t.program,r);t.uniformBufferBindings[r]=this.shader.uniformBindCount,i.uniformBlockBinding(t.program,n,this.shader.uniformBindCount),this.shader.uniformBindCount++;const a=this.getSignature(e,this.shader.program.uniformData,"ubo");let o=this._uboCache[a];if(o||(o=this._uboCache[a]=er(e,this.shader.program.uniformData)),e.autoManage){const h=new Float32Array(o.size/4);e.buffer.update(h)}return t.uniformGroups[e.id]=o.syncFunc,t.uniformGroups[e.id]}getSignature(e,t,r){const i=e.uniforms,n=[`${r}-`];for(const a in i)n.push(a),t[a]&&n.push(t[a].type);return n.join("-")}getGlProgram(){return this.shader?this.shader.program.glPrograms[this.renderer.CONTEXT_UID]:null}generateProgram(e){const t=this.gl,r=e.program,i=rr(t,r);return r.glPrograms[this.renderer.CONTEXT_UID]=i,i}reset(){this.program=null,this.shader=null}destroy(){this.renderer=null,this.destroyed=!0}}rt.extension={type:_.RendererSystem,name:"shader"},T.add(rt);function Jr(s,e=[]){return e[g.NORMAL]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.ADD]=[s.ONE,s.ONE],e[g.MULTIPLY]=[s.DST_COLOR,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.SCREEN]=[s.ONE,s.ONE_MINUS_SRC_COLOR,s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.OVERLAY]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.DARKEN]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.LIGHTEN]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.COLOR_DODGE]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.COLOR_BURN]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.HARD_LIGHT]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.SOFT_LIGHT]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.DIFFERENCE]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.EXCLUSION]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.HUE]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.SATURATION]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.COLOR]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.LUMINOSITY]=[s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.NONE]=[0,0],e[g.NORMAL_NPM]=[s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.ADD_NPM]=[s.SRC_ALPHA,s.ONE,s.ONE,s.ONE],e[g.SCREEN_NPM]=[s.SRC_ALPHA,s.ONE_MINUS_SRC_COLOR,s.ONE,s.ONE_MINUS_SRC_ALPHA],e[g.SRC_IN]=[s.DST_ALPHA,s.ZERO],e[g.SRC_OUT]=[s.ONE_MINUS_DST_ALPHA,s.ZERO],e[g.SRC_ATOP]=[s.DST_ALPHA,s.ONE_MINUS_SRC_ALPHA],e[g.DST_OVER]=[s.ONE_MINUS_DST_ALPHA,s.ONE],e[g.DST_IN]=[s.ZERO,s.SRC_ALPHA],e[g.DST_OUT]=[s.ZERO,s.ONE_MINUS_SRC_ALPHA],e[g.DST_ATOP]=[s.ONE_MINUS_DST_ALPHA,s.SRC_ALPHA],e[g.XOR]=[s.ONE_MINUS_DST_ALPHA,s.ONE_MINUS_SRC_ALPHA],e[g.SUBTRACT]=[s.ONE,s.ONE,s.ONE,s.ONE,s.FUNC_REVERSE_SUBTRACT,s.FUNC_ADD],e}const es=0,ts=1,rs=2,ss=3,is=4,ns=5,st=class{constructor(){this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode=g.NONE,this._blendEq=!1,this.map=[],this.map[es]=this.setBlend,this.map[ts]=this.setOffset,this.map[rs]=this.setCullFace,this.map[ss]=this.setDepthTest,this.map[is]=this.setFrontFace,this.map[ns]=this.setDepthMask,this.checks=[],this.defaultState=new Z,this.defaultState.blend=!0}contextChange(s){this.gl=s,this.blendModes=Jr(s),this.set(this.defaultState),this.reset()}set(s){if(s=s||this.defaultState,this.stateId!==s.data){let e=this.stateId^s.data,t=0;for(;e;)e&1&&this.map[t].call(this,!!(s.data&1<<t)),e=e>>1,t++;this.stateId=s.data}for(let e=0;e<this.checks.length;e++)this.checks[e](this,s)}forceState(s){s=s||this.defaultState;for(let e=0;e<this.map.length;e++)this.map[e].call(this,!!(s.data&1<<e));for(let e=0;e<this.checks.length;e++)this.checks[e](this,s);this.stateId=s.data}setBlend(s){this.updateCheck(st.checkBlendMode,s),this.gl[s?"enable":"disable"](this.gl.BLEND)}setOffset(s){this.updateCheck(st.checkPolygonOffset,s),this.gl[s?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(s){this.gl[s?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(s){this.gl.depthMask(s)}setCullFace(s){this.gl[s?"enable":"disable"](this.gl.CULL_FACE)}setFrontFace(s){this.gl.frontFace(this.gl[s?"CW":"CCW"])}setBlendMode(s){if(s===this.blendMode)return;this.blendMode=s;const e=this.blendModes[s],t=this.gl;e.length===2?t.blendFunc(e[0],e[1]):t.blendFuncSeparate(e[0],e[1],e[2],e[3]),e.length===6?(this._blendEq=!0,t.blendEquationSeparate(e[4],e[5])):this._blendEq&&(this._blendEq=!1,t.blendEquationSeparate(t.FUNC_ADD,t.FUNC_ADD))}setPolygonOffset(s,e){this.gl.polygonOffset(s,e)}reset(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode=-1,this.setBlendMode(0)}updateCheck(s,e){const t=this.checks.indexOf(s);e&&t===-1?this.checks.push(s):!e&&t!==-1&&this.checks.splice(t,1)}static checkBlendMode(s,e){s.setBlendMode(e.blendMode)}static checkPolygonOffset(s,e){s.setPolygonOffset(1,e.polygonOffset)}destroy(){this.gl=null}};let it=st;it.extension={type:_.RendererSystem,name:"state"},T.add(it);class nt{constructor(e){this.renderer=e,this.count=0,this.checkCount=0,this.maxIdle=m.GC_MAX_IDLE,this.checkCountMax=m.GC_MAX_CHECK_COUNT,this.mode=m.GC_MODE}postrender(){!this.renderer.objectRenderer.renderingToScreen||(this.count++,this.mode!==lr.MANUAL&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const e=this.renderer.texture,t=e.managedTextures;let r=!1;for(let i=0;i<t.length;i++){const n=t[i];!n.framebuffer&&this.count-n.touched>this.maxIdle&&(e.destroyTexture(n,!0),t[i]=null,r=!0)}if(r){let i=0;for(let n=0;n<t.length;n++)t[n]!==null&&(t[i++]=t[n]);t.length=i}}unload(e){const t=this.renderer.texture,r=e._texture;r&&!r.framebuffer&&t.destroyTexture(r);for(let i=e.children.length-1;i>=0;i--)this.unload(e.children[i])}destroy(){this.renderer=null}}nt.extension={type:_.RendererSystem,name:"textureGC"},T.add(nt);function as(s){let e;return"WebGL2RenderingContext"in globalThis&&s instanceof globalThis.WebGL2RenderingContext?e={[x.UNSIGNED_BYTE]:{[c.RGBA]:s.RGBA8,[c.RGB]:s.RGB8,[c.RG]:s.RG8,[c.RED]:s.R8,[c.RGBA_INTEGER]:s.RGBA8UI,[c.RGB_INTEGER]:s.RGB8UI,[c.RG_INTEGER]:s.RG8UI,[c.RED_INTEGER]:s.R8UI,[c.ALPHA]:s.ALPHA,[c.LUMINANCE]:s.LUMINANCE,[c.LUMINANCE_ALPHA]:s.LUMINANCE_ALPHA},[x.BYTE]:{[c.RGBA]:s.RGBA8_SNORM,[c.RGB]:s.RGB8_SNORM,[c.RG]:s.RG8_SNORM,[c.RED]:s.R8_SNORM,[c.RGBA_INTEGER]:s.RGBA8I,[c.RGB_INTEGER]:s.RGB8I,[c.RG_INTEGER]:s.RG8I,[c.RED_INTEGER]:s.R8I},[x.UNSIGNED_SHORT]:{[c.RGBA_INTEGER]:s.RGBA16UI,[c.RGB_INTEGER]:s.RGB16UI,[c.RG_INTEGER]:s.RG16UI,[c.RED_INTEGER]:s.R16UI,[c.DEPTH_COMPONENT]:s.DEPTH_COMPONENT16},[x.SHORT]:{[c.RGBA_INTEGER]:s.RGBA16I,[c.RGB_INTEGER]:s.RGB16I,[c.RG_INTEGER]:s.RG16I,[c.RED_INTEGER]:s.R16I},[x.UNSIGNED_INT]:{[c.RGBA_INTEGER]:s.RGBA32UI,[c.RGB_INTEGER]:s.RGB32UI,[c.RG_INTEGER]:s.RG32UI,[c.RED_INTEGER]:s.R32UI,[c.DEPTH_COMPONENT]:s.DEPTH_COMPONENT24},[x.INT]:{[c.RGBA_INTEGER]:s.RGBA32I,[c.RGB_INTEGER]:s.RGB32I,[c.RG_INTEGER]:s.RG32I,[c.RED_INTEGER]:s.R32I},[x.FLOAT]:{[c.RGBA]:s.RGBA32F,[c.RGB]:s.RGB32F,[c.RG]:s.RG32F,[c.RED]:s.R32F,[c.DEPTH_COMPONENT]:s.DEPTH_COMPONENT32F},[x.HALF_FLOAT]:{[c.RGBA]:s.RGBA16F,[c.RGB]:s.RGB16F,[c.RG]:s.RG16F,[c.RED]:s.R16F},[x.UNSIGNED_SHORT_5_6_5]:{[c.RGB]:s.RGB565},[x.UNSIGNED_SHORT_4_4_4_4]:{[c.RGBA]:s.RGBA4},[x.UNSIGNED_SHORT_5_5_5_1]:{[c.RGBA]:s.RGB5_A1},[x.UNSIGNED_INT_2_10_10_10_REV]:{[c.RGBA]:s.RGB10_A2,[c.RGBA_INTEGER]:s.RGB10_A2UI},[x.UNSIGNED_INT_10F_11F_11F_REV]:{[c.RGB]:s.R11F_G11F_B10F},[x.UNSIGNED_INT_5_9_9_9_REV]:{[c.RGB]:s.RGB9_E5},[x.UNSIGNED_INT_24_8]:{[c.DEPTH_STENCIL]:s.DEPTH24_STENCIL8},[x.FLOAT_32_UNSIGNED_INT_24_8_REV]:{[c.DEPTH_STENCIL]:s.DEPTH32F_STENCIL8}}:e={[x.UNSIGNED_BYTE]:{[c.RGBA]:s.RGBA,[c.RGB]:s.RGB,[c.ALPHA]:s.ALPHA,[c.LUMINANCE]:s.LUMINANCE,[c.LUMINANCE_ALPHA]:s.LUMINANCE_ALPHA},[x.UNSIGNED_SHORT_5_6_5]:{[c.RGB]:s.RGB},[x.UNSIGNED_SHORT_4_4_4_4]:{[c.RGBA]:s.RGBA},[x.UNSIGNED_SHORT_5_5_5_1]:{[c.RGBA]:s.RGBA}},e}class Re{constructor(e){this.texture=e,this.width=-1,this.height=-1,this.dirtyId=-1,this.dirtyStyleId=-1,this.mipmap=!1,this.wrapMode=33071,this.type=x.UNSIGNED_BYTE,this.internalFormat=c.RGBA,this.samplerType=0}}class at{constructor(e){this.renderer=e,this.boundTextures=[],this.currentLocation=-1,this.managedTextures=[],this._unknownBoundTextures=!1,this.unknownTexture=new y,this.hasIntegerTextures=!1}contextChange(){const e=this.gl=this.renderer.gl;this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.webGLVersion=this.renderer.context.webGLVersion,this.internalFormats=as(e);const t=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);this.boundTextures.length=t;for(let i=0;i<t;i++)this.boundTextures[i]=null;this.emptyTextures={};const r=new Re(e.createTexture());e.bindTexture(e.TEXTURE_2D,r.texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,new Uint8Array(4)),this.emptyTextures[e.TEXTURE_2D]=r,this.emptyTextures[e.TEXTURE_CUBE_MAP]=new Re(e.createTexture()),e.bindTexture(e.TEXTURE_CUBE_MAP,this.emptyTextures[e.TEXTURE_CUBE_MAP].texture);for(let i=0;i<6;i++)e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,null);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR);for(let i=0;i<this.boundTextures.length;i++)this.bind(null,i)}bind(e,t=0){const{gl:r}=this;if(e=e?.castToBaseTexture(),e?.valid&&!e.parentTextureArray){e.touched=this.renderer.textureGC.count;const i=e._glTextures[this.CONTEXT_UID]||this.initTexture(e);this.boundTextures[t]!==e&&(this.currentLocation!==t&&(this.currentLocation=t,r.activeTexture(r.TEXTURE0+t)),r.bindTexture(e.target,i.texture)),i.dirtyId!==e.dirtyId?(this.currentLocation!==t&&(this.currentLocation=t,r.activeTexture(r.TEXTURE0+t)),this.updateTexture(e)):i.dirtyStyleId!==e.dirtyStyleId&&this.updateTextureStyle(e),this.boundTextures[t]=e}else this.currentLocation!==t&&(this.currentLocation=t,r.activeTexture(r.TEXTURE0+t)),r.bindTexture(r.TEXTURE_2D,this.emptyTextures[r.TEXTURE_2D].texture),this.boundTextures[t]=null}reset(){this._unknownBoundTextures=!0,this.hasIntegerTextures=!1,this.currentLocation=-1;for(let e=0;e<this.boundTextures.length;e++)this.boundTextures[e]=this.unknownTexture}unbind(e){const{gl:t,boundTextures:r}=this;if(this._unknownBoundTextures){this._unknownBoundTextures=!1;for(let i=0;i<r.length;i++)r[i]===this.unknownTexture&&this.bind(null,i)}for(let i=0;i<r.length;i++)r[i]===e&&(this.currentLocation!==i&&(t.activeTexture(t.TEXTURE0+i),this.currentLocation=i),t.bindTexture(e.target,this.emptyTextures[e.target].texture),r[i]=null)}ensureSamplerType(e){const{boundTextures:t,hasIntegerTextures:r,CONTEXT_UID:i}=this;if(r)for(let n=e-1;n>=0;--n){const a=t[n];a&&a._glTextures[i].samplerType!==xt.FLOAT&&this.renderer.texture.unbind(a)}}initTexture(e){const t=new Re(this.gl.createTexture());return t.dirtyId=-1,e._glTextures[this.CONTEXT_UID]=t,this.managedTextures.push(e),e.on("dispose",this.destroyTexture,this),t}initTextureType(e,t){t.internalFormat=this.internalFormats[e.type]?.[e.format]??e.format,this.webGLVersion===2&&e.type===x.HALF_FLOAT?t.type=this.gl.HALF_FLOAT:t.type=e.type}updateTexture(e){const t=e._glTextures[this.CONTEXT_UID];if(!t)return;const r=this.renderer;if(this.initTextureType(e,t),e.resource?.upload(r,e,t))t.samplerType!==xt.FLOAT&&(this.hasIntegerTextures=!0);else{const i=e.realWidth,n=e.realHeight,a=r.gl;(t.width!==i||t.height!==n||t.dirtyId<0)&&(t.width=i,t.height=n,a.texImage2D(e.target,0,t.internalFormat,i,n,0,e.format,t.type,null))}e.dirtyStyleId!==t.dirtyStyleId&&this.updateTextureStyle(e),t.dirtyId=e.dirtyId}destroyTexture(e,t){const{gl:r}=this;if(e=e.castToBaseTexture(),e._glTextures[this.CONTEXT_UID]&&(this.unbind(e),r.deleteTexture(e._glTextures[this.CONTEXT_UID].texture),e.off("dispose",this.destroyTexture,this),delete e._glTextures[this.CONTEXT_UID],!t)){const i=this.managedTextures.indexOf(e);i!==-1&&mr(this.managedTextures,i,1)}}updateTextureStyle(e){const t=e._glTextures[this.CONTEXT_UID];!t||((e.mipmap===J.POW2||this.webGLVersion!==2)&&!e.isPowerOfTwo?t.mipmap=!1:t.mipmap=e.mipmap>=1,this.webGLVersion!==2&&!e.isPowerOfTwo?t.wrapMode=dr.CLAMP:t.wrapMode=e.wrapMode,e.resource?.style(this.renderer,e,t)||this.setStyle(e,t),t.dirtyStyleId=e.dirtyStyleId)}setStyle(e,t){const r=this.gl;if(t.mipmap&&e.mipmap!==J.ON_MANUAL&&r.generateMipmap(e.target),r.texParameteri(e.target,r.TEXTURE_WRAP_S,t.wrapMode),r.texParameteri(e.target,r.TEXTURE_WRAP_T,t.wrapMode),t.mipmap){r.texParameteri(e.target,r.TEXTURE_MIN_FILTER,e.scaleMode===D.LINEAR?r.LINEAR_MIPMAP_LINEAR:r.NEAREST_MIPMAP_NEAREST);const i=this.renderer.context.extensions.anisotropicFiltering;if(i&&e.anisotropicLevel>0&&e.scaleMode===D.LINEAR){const n=Math.min(e.anisotropicLevel,r.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT));r.texParameterf(e.target,i.TEXTURE_MAX_ANISOTROPY_EXT,n)}}else r.texParameteri(e.target,r.TEXTURE_MIN_FILTER,e.scaleMode===D.LINEAR?r.LINEAR:r.NEAREST);r.texParameteri(e.target,r.TEXTURE_MAG_FILTER,e.scaleMode===D.LINEAR?r.LINEAR:r.NEAREST)}destroy(){this.renderer=null}}at.extension={type:_.RendererSystem,name:"texture"},T.add(at);const os=new cr;class ot{constructor(e){this.renderer=e,this._tempMatrix=new M}generateTexture(e,t){const{region:r,...i}=t||{},n=r||e.getLocalBounds(null,!0);n.width===0&&(n.width=1),n.height===0&&(n.height=1);const a=ae.create({width:n.width,height:n.height,...i});this._tempMatrix.tx=-n.x,this._tempMatrix.ty=-n.y;const o=e.transform;return e.transform=os,this.renderer.render(e,{renderTexture:a,transform:this._tempMatrix,skipUpdateTransform:!!e.parent,blit:!0}),e.transform=o,a}destroy(){}}ot.extension={type:[_.RendererSystem,_.CanvasRendererSystem],name:"textureGenerator"},T.add(ot);class ht{constructor(){this.clearBeforeRender=!0,this._backgroundColor=0,this._backgroundColorRgba=[0,0,0,1],this._backgroundColorString="#000000",this.color=this._backgroundColor,this.alpha=1}init(e){this.clearBeforeRender=e.clearBeforeRender,this.color=e.color||this._backgroundColor,this.alpha=e.alpha}get color(){return this._backgroundColor}set color(e){this._backgroundColor=e,this._backgroundColorString=pr(e),gr(e,this._backgroundColorRgba)}get alpha(){return this._backgroundColorRgba[3]}set alpha(e){this._backgroundColorRgba[3]=e}get colorRgba(){return this._backgroundColorRgba}get colorString(){return this._backgroundColorString}destroy(){}}ht.extension={type:[_.RendererSystem,_.CanvasRendererSystem],name:"background"},T.add(ht);class ut{constructor(e){this.renderer=e}init(e){this.screen=new w(0,0,e.width,e.height),this.element=e.view||m.ADAPTER.createCanvas(),this.resolution=e.resolution||m.RESOLUTION,this.autoDensity=!!e.autoDensity}resizeView(e,t){this.element.width=Math.round(e*this.resolution),this.element.height=Math.round(t*this.resolution);const r=this.element.width/this.resolution,i=this.element.height/this.resolution;this.screen.width=r,this.screen.height=i,this.autoDensity&&(this.element.style.width=`${r}px`,this.element.style.height=`${i}px`),this.renderer.emit("resize",r,i),this.renderer.runners.resize.emit(this.screen.width,this.screen.height)}destroy(e){e&&this.element.parentNode&&this.element.parentNode.removeChild(this.element),this.renderer=null,this.element=null,this.screen=null}}ut.extension={type:[_.RendererSystem,_.CanvasRendererSystem],name:"_view"},T.add(ut);class lt{constructor(e){this.renderer=e,this.plugins={}}init(e){for(const t in e)this.plugins[t]=new e[t](this.renderer)}destroy(){for(const e in this.plugins)this.plugins[e].destroy(),this.plugins[e]=null}}lt.extension={type:[_.RendererSystem,_.CanvasRendererSystem],name:"_plugin"},T.add(lt);class sr extends Ae{constructor(){super(...arguments),this.runners={},this._systemsHash={}}setup(e){this.addRunners(...e.runners);const t=(e.priority??[]).filter(i=>e.systems[i]),r=[...t,...Object.keys(e.systems).filter(i=>!t.includes(i))];for(const i of r)this.addSystem(e.systems[i],i)}addRunners(...e){e.forEach(t=>{this.runners[t]=new L(t)})}addSystem(e,t){const r=new e(this);if(this[t])throw new Error(`Whoops! The name "${t}" is already in use`);this[t]=r,this._systemsHash[t]=r;for(const i in this.runners)this.runners[i].add(r);return this}emitWithCustomOptions(e,t){const r=Object.keys(this._systemsHash);e.items.forEach(i=>{const n=r.find(a=>this._systemsHash[a]===i);i[e.name](t[n])})}destroy(){Object.values(this.runners).forEach(e=>{e.destroy()}),this._systemsHash={}}}class dt{constructor(e){this.renderer=e}run(e){const t=this.renderer;t.emitWithCustomOptions(t.runners.init,e),_r(t.rendererLogId),t.resize(this.renderer.screen.width,this.renderer.screen.height)}destroy(){}}dt.extension={type:[_.RendererSystem,_.CanvasRendererSystem],name:"startup"},T.add(dt);const ir=[];T.handleByList(_.Renderer,ir);function hs(s){for(const e of ir)if(e.test(s))return new e(s);throw new Error("Unable to auto-detect a suitable renderer.")}var us=`attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,ls=`attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;const ds=us,cs=ls,ct=class extends sr{constructor(s){super(),s=Object.assign({},m.RENDER_OPTIONS,s),this.gl=null,this.CONTEXT_UID=0,this.globalUniforms=new F({projectionMatrix:new M},!0);const e={runners:["init","destroy","contextChange","reset","update","postrender","prerender","resize"],systems:ct.__systems,priority:["_view","textureGenerator","background","_plugin","startup","context","state","texture","buffer","geometry","framebuffer","mask","scissor","stencil","projection","textureGC","filter","renderTexture","batch","objectRenderer","_multisample"]};this.setup(e);const t={_plugin:ct.__plugins,background:{alpha:s.backgroundAlpha,color:s.backgroundColor,clearBeforeRender:s.clearBeforeRender},_view:{height:s.height,width:s.width,autoDensity:s.autoDensity,resolution:s.resolution,view:s.view},context:{antialias:s.antialias,context:s.context,powerPreference:s.powerPreference,premultipliedAlpha:s.premultipliedAlpha??(s.useContextAlpha&&s.useContextAlpha!=="notMultiplied"),preserveDrawingBuffer:s.preserveDrawingBuffer}};this.startup.run(t)}static test(s){return s?.forceCanvas?!1:xr()}render(s,e){this.objectRenderer.render(s,e)}resize(s,e){this._view.resizeView(s,e)}reset(){return this.runners.reset.emit(),this}clear(){this.renderTexture.bind(),this.renderTexture.clear()}destroy(s=!1){this.runners.destroy.items.reverse(),this.emitWithCustomOptions(this.runners.destroy,{_view:s}),super.destroy()}get plugins(){return this._plugin.plugins}get multisample(){return this._multisample.multisample}get width(){return this._view.element.width}get height(){return this._view.element.height}get resolution(){return this._view.resolution}get autoDensity(){return this._view.autoDensity}get view(){return this._view.element}get screen(){return this._view.screen}get lastObjectRendered(){return this.objectRenderer.lastObjectRendered}get renderingToScreen(){return this.objectRenderer.renderingToScreen}get rendererLogId(){return`WebGL ${this.context.webGLVersion}`}get clearBeforeRender(){return this.background.clearBeforeRender}get useContextAlpha(){return this.context.useContextAlpha}get preserveDrawingBuffer(){return this.context.preserveDrawingBuffer}get backgroundColor(){return this.background.color}set backgroundColor(s){this.background.color=s}get backgroundAlpha(){return this.background.color}set backgroundAlpha(s){this.background.alpha=s}get powerPreference(){return this.context.powerPreference}generateTexture(s,e){return this.textureGenerator.generateTexture(s,e)}};let H=ct;H.extension={type:_.Renderer,priority:1},H.__plugins={},H.__systems={},T.handleByMap(_.RendererPlugin,H.__plugins),T.handleByMap(_.RendererSystem,H.__systems),T.add(H);class nr{constructor(){this.texArray=null,this.blend=0,this.type=we.TRIANGLES,this.start=0,this.size=0,this.data=null}}class ar{constructor(){this.elements=[],this.ids=[],this.count=0}clear(){for(let e=0;e<this.count;e++)this.elements[e]=null;this.count=0}}class or{constructor(e){typeof e=="number"?this.rawBinaryData=new ArrayBuffer(e):e instanceof Uint8Array?this.rawBinaryData=e.buffer:this.rawBinaryData=e,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData)}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get uint16View(){return this._uint16View||(this._uint16View=new Uint16Array(this.rawBinaryData)),this._uint16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}view(e){return this[`${e}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this._uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(e){switch(e){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${e} isn't a valid view type`)}}}class hr{constructor(e,t){if(this.vertexSrc=e,this.fragTemplate=t,this.programCache={},this.defaultGroupCache={},!t.includes("%count%"))throw new Error('Fragment template must contain "%count%".');if(!t.includes("%forloop%"))throw new Error('Fragment template must contain "%forloop%".')}generateShader(e){if(!this.programCache[e]){const r=new Int32Array(e);for(let n=0;n<e;n++)r[n]=n;this.defaultGroupCache[e]=F.from({uSamplers:r},!0);let i=this.fragTemplate;i=i.replace(/%count%/gi,`${e}`),i=i.replace(/%forloop%/gi,this.generateSampleSrc(e)),this.programCache[e]=new U(this.vertexSrc,i)}const t={tint:new Float32Array([1,1,1,1]),translationMatrix:new M,default:this.defaultGroupCache[e]};return new he(this.programCache[e],t)}generateSampleSrc(e){let t="";t+=`
`,t+=`
`;for(let r=0;r<e;r++)r>0&&(t+=`
else `),r<e-1&&(t+=`if(vTextureId < ${r}.5)`),t+=`
{`,t+=`
	color = texture2D(uSamplers[${r}], vTextureCoord);`,t+=`
}`;return t+=`
`,t+=`
`,t}}class ur extends X{constructor(e=!1){super(),this._buffer=new A(null,e,!1),this._indexBuffer=new A(null,e,!0),this.addAttribute("aVertexPosition",this._buffer,2,!1,x.FLOAT).addAttribute("aTextureCoord",this._buffer,2,!1,x.FLOAT).addAttribute("aColor",this._buffer,4,!0,x.UNSIGNED_BYTE).addAttribute("aTextureId",this._buffer,1,!0,x.FLOAT).addIndex(this._indexBuffer)}}var fs=`precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`,ms=`varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`;const $=class extends Le{constructor(s){super(s),this.setShaderGenerator(),this.geometryClass=ur,this.vertexSize=6,this.state=Z.for2d(),this.size=m.SPRITE_BATCH_SIZE*4,this._vertexCount=0,this._indexCount=0,this._bufferedElements=[],this._bufferedTextures=[],this._bufferSize=0,this._shader=null,this._packedGeometries=[],this._packedGeometryPoolSize=2,this._flushId=0,this._aBuffers={},this._iBuffers={},this.MAX_TEXTURES=1,this.renderer.on("prerender",this.onPrerender,this),s.runners.contextChange.add(this),this._dcIndex=0,this._aIndex=0,this._iIndex=0,this._attributeBuffer=null,this._indexBuffer=null,this._tempBoundTextures=[]}static get defaultVertexSrc(){return fs}static get defaultFragmentTemplate(){return ms}setShaderGenerator({vertex:s=$.defaultVertexSrc,fragment:e=$.defaultFragmentTemplate}={}){this.shaderGenerator=new hr(s,e)}contextChange(){const s=this.renderer.gl;m.PREFER_ENV===z.WEBGL_LEGACY?this.MAX_TEXTURES=1:(this.MAX_TEXTURES=Math.min(s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),m.SPRITE_MAX_TEXTURES),this.MAX_TEXTURES=Xt(this.MAX_TEXTURES,s)),this._shader=this.shaderGenerator.generateShader(this.MAX_TEXTURES);for(let e=0;e<this._packedGeometryPoolSize;e++)this._packedGeometries[e]=new this.geometryClass;this.initFlushBuffers()}initFlushBuffers(){const{_drawCallPool:s,_textureArrayPool:e}=$,t=this.size/4,r=Math.floor(t/this.MAX_TEXTURES)+1;for(;s.length<t;)s.push(new nr);for(;e.length<r;)e.push(new ar);for(let i=0;i<this.MAX_TEXTURES;i++)this._tempBoundTextures[i]=null}onPrerender(){this._flushId=0}render(s){!s._texture.valid||(this._vertexCount+s.vertexData.length/2>this.size&&this.flush(),this._vertexCount+=s.vertexData.length/2,this._indexCount+=s.indices.length,this._bufferedTextures[this._bufferSize]=s._texture.baseTexture,this._bufferedElements[this._bufferSize++]=s)}buildTexturesAndDrawCalls(){const{_bufferedTextures:s,MAX_TEXTURES:e}=this,t=$._textureArrayPool,r=this.renderer.batch,i=this._tempBoundTextures,n=this.renderer.textureGC.count;let a=++y._globalBatch,o=0,h=t[0],u=0;r.copyBoundTextures(i,e);for(let l=0;l<this._bufferSize;++l){const d=s[l];s[l]=null,d._batchEnabled!==a&&(h.count>=e&&(r.boundArray(h,i,a,e),this.buildDrawCalls(h,u,l),u=l,h=t[++o],++a),d._batchEnabled=a,d.touched=n,h.elements[h.count++]=d)}h.count>0&&(r.boundArray(h,i,a,e),this.buildDrawCalls(h,u,this._bufferSize),++o,++a);for(let l=0;l<i.length;l++)i[l]=null;y._globalBatch=a}buildDrawCalls(s,e,t){const{_bufferedElements:r,_attributeBuffer:i,_indexBuffer:n,vertexSize:a}=this,o=$._drawCallPool;let h=this._dcIndex,u=this._aIndex,l=this._iIndex,d=o[h];d.start=this._iIndex,d.texArray=s;for(let f=e;f<t;++f){const p=r[f],b=p._texture.baseTexture,v=vr[b.alphaMode?1:0][p.blendMode];r[f]=null,e<f&&d.blend!==v&&(d.size=l-d.start,e=f,d=o[++h],d.texArray=s,d.start=l),this.packInterleavedGeometry(p,i,n,u,l),u+=p.vertexData.length/2*a,l+=p.indices.length,d.blend=v}e<t&&(d.size=l-d.start,++h),this._dcIndex=h,this._aIndex=u,this._iIndex=l}bindAndClearTexArray(s){const e=this.renderer.texture;for(let t=0;t<s.count;t++)e.bind(s.elements[t],s.ids[t]),s.elements[t]=null;s.count=0}updateGeometry(){const{_packedGeometries:s,_attributeBuffer:e,_indexBuffer:t}=this;m.CAN_UPLOAD_SAME_BUFFER?(s[this._flushId]._buffer.update(e.rawBinaryData),s[this._flushId]._indexBuffer.update(t),this.renderer.geometry.updateBuffers()):(this._packedGeometryPoolSize<=this._flushId&&(this._packedGeometryPoolSize++,s[this._flushId]=new this.geometryClass),s[this._flushId]._buffer.update(e.rawBinaryData),s[this._flushId]._indexBuffer.update(t),this.renderer.geometry.bind(s[this._flushId]),this.renderer.geometry.updateBuffers(),this._flushId++)}drawBatches(){const s=this._dcIndex,{gl:e,state:t}=this.renderer,r=$._drawCallPool;let i=null;for(let n=0;n<s;n++){const{texArray:a,type:o,size:h,start:u,blend:l}=r[n];i!==a&&(i=a,this.bindAndClearTexArray(a)),this.state.blendMode=l,t.set(this.state),e.drawElements(o,h,e.UNSIGNED_SHORT,u*2)}}flush(){this._vertexCount!==0&&(this._attributeBuffer=this.getAttributeBuffer(this._vertexCount),this._indexBuffer=this.getIndexBuffer(this._indexCount),this._aIndex=0,this._iIndex=0,this._dcIndex=0,this.buildTexturesAndDrawCalls(),this.updateGeometry(),this.drawBatches(),this._bufferSize=0,this._vertexCount=0,this._indexCount=0)}start(){this.renderer.state.set(this.state),this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),this.renderer.shader.bind(this._shader),m.CAN_UPLOAD_SAME_BUFFER&&this.renderer.geometry.bind(this._packedGeometries[this._flushId])}stop(){this.flush()}destroy(){for(let s=0;s<this._packedGeometryPoolSize;s++)this._packedGeometries[s]&&this._packedGeometries[s].destroy();this.renderer.off("prerender",this.onPrerender,this),this._aBuffers=null,this._iBuffers=null,this._packedGeometries=null,this._attributeBuffer=null,this._indexBuffer=null,this._shader&&(this._shader.destroy(),this._shader=null),super.destroy()}getAttributeBuffer(s){const e=le(Math.ceil(s/8)),t=yt(e),r=e*8;this._aBuffers.length<=t&&(this._iBuffers.length=t+1);let i=this._aBuffers[r];return i||(this._aBuffers[r]=i=new or(r*this.vertexSize*4)),i}getIndexBuffer(s){const e=le(Math.ceil(s/12)),t=yt(e),r=e*12;this._iBuffers.length<=t&&(this._iBuffers.length=t+1);let i=this._iBuffers[t];return i||(this._iBuffers[t]=i=new Uint16Array(r)),i}packInterleavedGeometry(s,e,t,r,i){const{uint32View:n,float32View:a}=e,o=r/this.vertexSize,h=s.uvs,u=s.indices,l=s.vertexData,d=s._texture.baseTexture._batchLocation,f=Math.min(s.worldAlpha,1),p=f<1&&s._texture.baseTexture.alphaMode?Er(s._tintRGB,f):s._tintRGB+(f*255<<24);for(let b=0;b<l.length;b+=2)a[r++]=l[b],a[r++]=l[b+1],a[r++]=h[b],a[r++]=h[b+1],n[r++]=p,a[r++]=d;for(let b=0;b<u.length;b++)t[i++]=o+u[b]}};let ne=$;ne.extension={name:"batch",type:_.RendererPlugin},ne._drawCallPool=[],ne._textureArrayPool=[],T.add(ne);class ps{constructor(e){this.buffer=e||null,this.updateID=-1,this.byteLength=-1,this.refCount=0}}class ft{constructor(e){this.renderer=e,this.managedBuffers={},this.boundBufferBases={}}destroy(){this.renderer=null}contextChange(){this.disposeAll(!0),this.gl=this.renderer.gl,this.CONTEXT_UID=this.renderer.CONTEXT_UID}bind(e){const{gl:t,CONTEXT_UID:r}=this,i=e._glBuffers[r]||this.createGLBuffer(e);t.bindBuffer(e.type,i.buffer)}bindBufferBase(e,t){const{gl:r,CONTEXT_UID:i}=this;if(this.boundBufferBases[t]!==e){const n=e._glBuffers[i]||this.createGLBuffer(e);this.boundBufferBases[t]=e,r.bindBufferBase(r.UNIFORM_BUFFER,t,n.buffer)}}bindBufferRange(e,t,r){const{gl:i,CONTEXT_UID:n}=this;r=r||0;const a=e._glBuffers[n]||this.createGLBuffer(e);i.bindBufferRange(i.UNIFORM_BUFFER,t||0,a.buffer,r*256,256)}update(e){const{gl:t,CONTEXT_UID:r}=this,i=e._glBuffers[r];if(e._updateID!==i.updateID)if(i.updateID=e._updateID,t.bindBuffer(e.type,i.buffer),i.byteLength>=e.data.byteLength)t.bufferSubData(e.type,0,e.data);else{const n=e.static?t.STATIC_DRAW:t.DYNAMIC_DRAW;i.byteLength=e.data.byteLength,t.bufferData(e.type,e.data,n)}}dispose(e,t){if(!this.managedBuffers[e.id])return;delete this.managedBuffers[e.id];const r=e._glBuffers[this.CONTEXT_UID],i=this.gl;e.disposeRunner.remove(this),r&&(t||i.deleteBuffer(r.buffer),delete e._glBuffers[this.CONTEXT_UID])}disposeAll(e){const t=Object.keys(this.managedBuffers);for(let r=0;r<t.length;r++)this.dispose(this.managedBuffers[t[r]],e)}createGLBuffer(e){const{CONTEXT_UID:t,gl:r}=this;return e._glBuffers[t]=new ps(r.createBuffer()),this.managedBuffers[e.id]=e,e.disposeRunner.add(this),e._glBuffers[t]}}ft.extension={type:_.RendererSystem,name:"buffer"},T.add(ft);class mt{constructor(e){this.renderer=e}contextChange(e){let t;if(this.renderer.context.webGLVersion===1){const r=e.getParameter(e.FRAMEBUFFER_BINDING);e.bindFramebuffer(e.FRAMEBUFFER,null),t=e.getParameter(e.SAMPLES),e.bindFramebuffer(e.FRAMEBUFFER,r)}else{const r=e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),t=e.getParameter(e.SAMPLES),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,r)}t>=S.HIGH?this.multisample=S.HIGH:t>=S.MEDIUM?this.multisample=S.MEDIUM:t>=S.LOW?this.multisample=S.LOW:this.multisample=S.NONE}destroy(){}}mt.extension={type:_.RendererSystem,name:"_multisample"},T.add(mt);class pt{constructor(e){this.renderer=e}render(e,t){const r=this.renderer;let i,n,a,o;if(t&&(i=t.renderTexture,n=t.clear,a=t.transform,o=t.skipUpdateTransform),this.renderingToScreen=!i,r.runners.prerender.emit(),r.emit("prerender"),r.projection.transform=a,!r.context.isLost){if(i||(this.lastObjectRendered=e),!o){const h=e.enableTempParent();e.updateTransform(),e.disableTempParent(h)}r.renderTexture.bind(i),r.batch.currentRenderer.start(),(n??r.background.clearBeforeRender)&&r.renderTexture.clear(),e.render(r),r.batch.currentRenderer.flush(),i&&(t.blit&&r.framebuffer.blit(),i.baseTexture.update()),r.runners.postrender.emit(),r.projection.transform=null,r.emit("postrender")}}destroy(){this.renderer=null,this.lastObjectRendered=null}}pt.extension={type:_.RendererSystem,name:"objectRenderer"},T.add(pt);const gs="7.0.0-alpha.3";export{Ce as AbstractMultiResource,St as ArrayResource,oe as Attribute,ht as BackgroundSystem,N as BaseImageResource,Ne as BaseRenderTexture,y as BaseTexture,nr as BatchDrawCall,ur as BatchGeometry,ne as BatchRenderer,hr as BatchShaderGenerator,Ge as BatchSystem,ar as BatchTextureArray,A as Buffer,ce as BufferResource,ft as BufferSystem,Rt as CanvasResource,ke as ContextSystem,Fe as CubeResource,ue as Filter,Mt as FilterState,De as FilterSystem,ge as Framebuffer,Ve as FramebufferSystem,Nt as GLFramebuffer,tr as GLProgram,Re as GLTexture,ot as GenerateTextureSystem,X as Geometry,$e as GeometrySystem,Kr as IGLUniformData,de as INSTALLED,wt as ImageBitmapResource,Me as ImageResource,Ot as MaskData,Ze as MaskSystem,mt as MultisampleSystem,Le as ObjectRenderer,pt as ObjectRendererSystem,lt as PluginSystem,U as Program,et as ProjectionSystem,Ct as Quad,Ft as QuadUv,ae as RenderTexture,Pe as RenderTexturePool,tt as RenderTextureSystem,H as Renderer,q as Resource,me as SVGResource,Qe as ScissorSystem,he as Shader,rt as ShaderSystem,Wt as SpriteMaskFilter,dt as StartupSystem,Z as State,it as StateSystem,Je as StencilSystem,sr as SystemManager,E as Texture,nt as TextureGCSystem,jt as TextureMatrix,at as TextureSystem,Oe as TextureUvs,F as UniformGroup,gs as VERSION,pe as VideoResource,ut as ViewSystem,or as ViewableBuffer,hs as autoDetectRenderer,Ie as autoDetectResource,Xt as checkMaxIfStatementsInShader,Qt as createUBOElements,cs as defaultFilterVertex,ds as defaultVertex,rr as generateProgram,er as generateUniformBufferSync,Gt as getTestContext,Jt as getUBOData,k as uniformParsers,Tr as utils};
//# sourceMappingURL=core.min.mjs.map
