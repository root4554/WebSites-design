/*!
 * @pixi/math - v7.0.0-alpha.3
 * Compiled Fri, 23 Sep 2022 14:33:14 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */const q=Math.PI*2,j=180/Math.PI,z=Math.PI/180;var l=(r=>(r[r.POLY=0]="POLY",r[r.RECT=1]="RECT",r[r.CIRC=2]="CIRC",r[r.ELIP=3]="ELIP",r[r.RREC=4]="RREC",r))(l||{});class u{constructor(t=0,s=0){this.x=0,this.y=0,this.x=t,this.y=s}clone(){return new u(this.x,this.y)}copyFrom(t){return this.set(t.x,t.y),this}copyTo(t){return t.set(this.x,this.y),t}equals(t){return t.x===this.x&&t.y===this.y}set(t=0,s=t){return this.x=t,this.y=s,this}}const E=[new u,new u,new u,new u];class D{constructor(t=0,s=0,i=0,h=0){this.x=Number(t),this.y=Number(s),this.width=Number(i),this.height=Number(h),this.type=l.RECT}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}static get EMPTY(){return new D(0,0,0,0)}clone(){return new D(this.x,this.y,this.width,this.height)}copyFrom(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this}copyTo(t){return t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t}contains(t,s){return this.width<=0||this.height<=0?!1:t>=this.x&&t<this.x+this.width&&s>=this.y&&s<this.y+this.height}intersects(t,s){if(!s){const H=this.x<t.x?t.x:this.x;if((this.right>t.right?t.right:this.right)<=H)return!1;const Z=this.y<t.y?t.y:this.y;return(this.bottom>t.bottom?t.bottom:this.bottom)>Z}const i=this.left,h=this.right,e=this.top,n=this.bottom;if(h<=i||n<=e)return!1;const a=E[0].set(t.left,t.top),o=E[1].set(t.left,t.bottom),c=E[2].set(t.right,t.top),y=E[3].set(t.right,t.bottom);if(c.x<=a.x||o.y<=a.y)return!1;const T=Math.sign(s.a*s.d-s.b*s.c);if(T===0||(s.apply(a,a),s.apply(o,o),s.apply(c,c),s.apply(y,y),Math.max(a.x,o.x,c.x,y.x)<=i||Math.min(a.x,o.x,c.x,y.x)>=h||Math.max(a.y,o.y,c.y,y.y)<=e||Math.min(a.y,o.y,c.y,y.y)>=n))return!1;const M=T*(o.y-a.y),m=T*(a.x-o.x),k=M*i+m*e,L=M*h+m*e,P=M*i+m*n,O=M*h+m*n;if(Math.max(k,L,P,O)<=M*a.x+m*a.y||Math.min(k,L,P,O)>=M*y.x+m*y.y)return!1;const I=T*(a.y-c.y),f=T*(c.x-a.x),Y=I*i+f*e,F=I*h+f*e,W=I*i+f*n,G=I*h+f*n;return!(Math.max(Y,F,W,G)<=I*a.x+f*a.y||Math.min(Y,F,W,G)>=I*y.x+f*y.y)}pad(t=0,s=t){return this.x-=t,this.y-=s,this.width+=t*2,this.height+=s*2,this}fit(t){const s=Math.max(this.x,t.x),i=Math.min(this.x+this.width,t.x+t.width),h=Math.max(this.y,t.y),e=Math.min(this.y+this.height,t.y+t.height);return this.x=s,this.width=Math.max(i-s,0),this.y=h,this.height=Math.max(e-h,0),this}ceil(t=1,s=.001){const i=Math.ceil((this.x+this.width-s)*t)/t,h=Math.ceil((this.y+this.height-s)*t)/t;return this.x=Math.floor((this.x+s)*t)/t,this.y=Math.floor((this.y+s)*t)/t,this.width=i-this.x,this.height=h-this.y,this}enlarge(t){const s=Math.min(this.x,t.x),i=Math.max(this.x+this.width,t.x+t.width),h=Math.min(this.y,t.y),e=Math.max(this.y+this.height,t.y+t.height);return this.x=s,this.width=i-s,this.y=h,this.height=e-h,this}}class A{constructor(t=0,s=0,i=0){this.x=t,this.y=s,this.radius=i,this.type=l.CIRC}clone(){return new A(this.x,this.y,this.radius)}contains(t,s){if(this.radius<=0)return!1;const i=this.radius*this.radius;let h=this.x-t,e=this.y-s;return h*=h,e*=e,h+e<=i}getBounds(){return new D(this.x-this.radius,this.y-this.radius,this.radius*2,this.radius*2)}}class C{constructor(t=0,s=0,i=0,h=0){this.x=t,this.y=s,this.width=i,this.height=h,this.type=l.ELIP}clone(){return new C(this.x,this.y,this.width,this.height)}contains(t,s){if(this.width<=0||this.height<=0)return!1;let i=(t-this.x)/this.width,h=(s-this.y)/this.height;return i*=i,h*=h,i+h<=1}getBounds(){return new D(this.x-this.width,this.y-this.height,this.width,this.height)}}class N{constructor(...t){let s=Array.isArray(t[0])?t[0]:t;if(typeof s[0]!="number"){const i=[];for(let h=0,e=s.length;h<e;h++)i.push(s[h].x,s[h].y);s=i}this.points=s,this.type=l.POLY,this.closeStroke=!0}clone(){const t=this.points.slice(),s=new N(t);return s.closeStroke=this.closeStroke,s}contains(t,s){let i=!1;const h=this.points.length/2;for(let e=0,n=h-1;e<h;n=e++){const a=this.points[e*2],o=this.points[e*2+1],c=this.points[n*2],y=this.points[n*2+1];o>s!=y>s&&t<(c-a)*((s-o)/(y-o))+a&&(i=!i)}return i}}class S{constructor(t=0,s=0,i=0,h=0,e=20){this.x=t,this.y=s,this.width=i,this.height=h,this.radius=e,this.type=l.RREC}clone(){return new S(this.x,this.y,this.width,this.height,this.radius)}contains(t,s){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&s>=this.y&&s<=this.y+this.height){const i=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(s>=this.y+i&&s<=this.y+this.height-i||t>=this.x+i&&t<=this.x+this.width-i)return!0;let h=t-(this.x+i),e=s-(this.y+i);const n=i*i;if(h*h+e*e<=n||(h=t-(this.x+this.width-i),h*h+e*e<=n)||(e=s-(this.y+this.height-i),h*h+e*e<=n)||(h=t-(this.x+i),h*h+e*e<=n))return!0}return!1}}class g{constructor(t,s,i=0,h=0){this._x=i,this._y=h,this.cb=t,this.scope=s}clone(t=this.cb,s=this.scope){return new g(t,s,this._x,this._y)}set(t=0,s=t){return(this._x!==t||this._y!==s)&&(this._x=t,this._y=s,this.cb.call(this.scope)),this}copyFrom(t){return(this._x!==t.x||this._y!==t.y)&&(this._x=t.x,this._y=t.y,this.cb.call(this.scope)),this}copyTo(t){return t.set(this._x,this._y),t}equals(t){return t.x===this._x&&t.y===this._y}get x(){return this._x}set x(t){this._x!==t&&(this._x=t,this.cb.call(this.scope))}get y(){return this._y}set y(t){this._y!==t&&(this._y=t,this.cb.call(this.scope))}}class d{constructor(t=1,s=0,i=0,h=1,e=0,n=0){this.array=null,this.a=t,this.b=s,this.c=i,this.d=h,this.tx=e,this.ty=n}fromArray(t){this.a=t[0],this.b=t[1],this.c=t[3],this.d=t[4],this.tx=t[2],this.ty=t[5]}set(t,s,i,h,e,n){return this.a=t,this.b=s,this.c=i,this.d=h,this.tx=e,this.ty=n,this}toArray(t,s){this.array||(this.array=new Float32Array(9));const i=s||this.array;return t?(i[0]=this.a,i[1]=this.b,i[2]=0,i[3]=this.c,i[4]=this.d,i[5]=0,i[6]=this.tx,i[7]=this.ty,i[8]=1):(i[0]=this.a,i[1]=this.c,i[2]=this.tx,i[3]=this.b,i[4]=this.d,i[5]=this.ty,i[6]=0,i[7]=0,i[8]=1),i}apply(t,s){s=s||new u;const i=t.x,h=t.y;return s.x=this.a*i+this.c*h+this.tx,s.y=this.b*i+this.d*h+this.ty,s}applyInverse(t,s){s=s||new u;const i=1/(this.a*this.d+this.c*-this.b),h=t.x,e=t.y;return s.x=this.d*i*h+-this.c*i*e+(this.ty*this.c-this.tx*this.d)*i,s.y=this.a*i*e+-this.b*i*h+(-this.ty*this.a+this.tx*this.b)*i,s}translate(t,s){return this.tx+=t,this.ty+=s,this}scale(t,s){return this.a*=t,this.d*=s,this.c*=t,this.b*=s,this.tx*=t,this.ty*=s,this}rotate(t){const s=Math.cos(t),i=Math.sin(t),h=this.a,e=this.c,n=this.tx;return this.a=h*s-this.b*i,this.b=h*i+this.b*s,this.c=e*s-this.d*i,this.d=e*i+this.d*s,this.tx=n*s-this.ty*i,this.ty=n*i+this.ty*s,this}append(t){const s=this.a,i=this.b,h=this.c,e=this.d;return this.a=t.a*s+t.b*h,this.b=t.a*i+t.b*e,this.c=t.c*s+t.d*h,this.d=t.c*i+t.d*e,this.tx=t.tx*s+t.ty*h+this.tx,this.ty=t.tx*i+t.ty*e+this.ty,this}setTransform(t,s,i,h,e,n,a,o,c){return this.a=Math.cos(a+c)*e,this.b=Math.sin(a+c)*e,this.c=-Math.sin(a-o)*n,this.d=Math.cos(a-o)*n,this.tx=t-(i*this.a+h*this.c),this.ty=s-(i*this.b+h*this.d),this}prepend(t){const s=this.tx;if(t.a!==1||t.b!==0||t.c!==0||t.d!==1){const i=this.a,h=this.c;this.a=i*t.a+this.b*t.c,this.b=i*t.b+this.b*t.d,this.c=h*t.a+this.d*t.c,this.d=h*t.b+this.d*t.d}return this.tx=s*t.a+this.ty*t.c+t.tx,this.ty=s*t.b+this.ty*t.d+t.ty,this}decompose(t){const s=this.a,i=this.b,h=this.c,e=this.d,n=t.pivot,a=-Math.atan2(-h,e),o=Math.atan2(i,s),c=Math.abs(a+o);return c<1e-5||Math.abs(q-c)<1e-5?(t.rotation=o,t.skew.x=t.skew.y=0):(t.rotation=0,t.skew.x=a,t.skew.y=o),t.scale.x=Math.sqrt(s*s+i*i),t.scale.y=Math.sqrt(h*h+e*e),t.position.x=this.tx+(n.x*s+n.y*h),t.position.y=this.ty+(n.x*i+n.y*e),t}invert(){const t=this.a,s=this.b,i=this.c,h=this.d,e=this.tx,n=t*h-s*i;return this.a=h/n,this.b=-s/n,this.c=-i/n,this.d=t/n,this.tx=(i*this.ty-h*e)/n,this.ty=-(t*this.ty-s*e)/n,this}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const t=new d;return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t}copyTo(t){return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t}copyFrom(t){return this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty,this}static get IDENTITY(){return new d}static get TEMP_MATRIX(){return new d}}const p=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],w=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],b=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],_=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],v=[],V=[],R=Math.sign;function J(){for(let r=0;r<16;r++){const t=[];v.push(t);for(let s=0;s<16;s++){const i=R(p[r]*p[s]+b[r]*w[s]),h=R(w[r]*p[s]+_[r]*w[s]),e=R(p[r]*b[s]+b[r]*_[s]),n=R(w[r]*b[s]+_[r]*_[s]);for(let a=0;a<16;a++)if(p[a]===i&&w[a]===h&&b[a]===e&&_[a]===n){t.push(a);break}}}for(let r=0;r<16;r++){const t=new d;t.set(p[r],w[r],b[r],_[r],0,0),V.push(t)}}J();const x={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:r=>p[r],uY:r=>w[r],vX:r=>b[r],vY:r=>_[r],inv:r=>r&8?r&15:-r&7,add:(r,t)=>v[r][t],sub:(r,t)=>v[r][x.inv(t)],rotate180:r=>r^4,isVertical:r=>(r&3)===2,byDirection:(r,t)=>Math.abs(r)*2<=Math.abs(t)?t>=0?x.S:x.N:Math.abs(t)*2<=Math.abs(r)?r>0?x.E:x.W:t>0?r>0?x.SE:x.SW:r>0?x.NE:x.NW,matrixAppendRotationInv:(r,t,s=0,i=0)=>{const h=V[x.inv(t)];h.tx=s,h.ty=i,r.append(h)}},X=class{constructor(){this.worldTransform=new d,this.localTransform=new d,this.position=new g(this.onChange,this,0,0),this.scale=new g(this.onChange,this,1,1),this.pivot=new g(this.onChange,this,0,0),this.skew=new g(this.updateSkew,this,0,0),this._rotation=0,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._localID=0,this._currentLocalID=0,this._worldID=0,this._parentID=0}onChange(){this._localID++}updateSkew(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this._localID++}updateLocalTransform(){const r=this.localTransform;this._localID!==this._currentLocalID&&(r.a=this._cx*this.scale.x,r.b=this._sx*this.scale.x,r.c=this._cy*this.scale.y,r.d=this._sy*this.scale.y,r.tx=this.position.x-(this.pivot.x*r.a+this.pivot.y*r.c),r.ty=this.position.y-(this.pivot.x*r.b+this.pivot.y*r.d),this._currentLocalID=this._localID,this._parentID=-1)}updateTransform(r){const t=this.localTransform;if(this._localID!==this._currentLocalID&&(t.a=this._cx*this.scale.x,t.b=this._sx*this.scale.x,t.c=this._cy*this.scale.y,t.d=this._sy*this.scale.y,t.tx=this.position.x-(this.pivot.x*t.a+this.pivot.y*t.c),t.ty=this.position.y-(this.pivot.x*t.b+this.pivot.y*t.d),this._currentLocalID=this._localID,this._parentID=-1),this._parentID!==r._worldID){const s=r.worldTransform,i=this.worldTransform;i.a=t.a*s.a+t.b*s.c,i.b=t.a*s.b+t.b*s.d,i.c=t.c*s.a+t.d*s.c,i.d=t.c*s.b+t.d*s.d,i.tx=t.tx*s.a+t.ty*s.c+s.tx,i.ty=t.tx*s.b+t.ty*s.d+s.ty,this._parentID=r._worldID,this._worldID++}}setFromMatrix(r){r.decompose(this),this._localID++}get rotation(){return this._rotation}set rotation(r){this._rotation!==r&&(this._rotation=r,this.updateSkew())}};let B=X;B.IDENTITY=new X;export{A as Circle,z as DEG_TO_RAD,C as Ellipse,d as Matrix,g as ObservablePoint,q as PI_2,u as Point,N as Polygon,j as RAD_TO_DEG,D as Rectangle,S as RoundedRectangle,l as SHAPES,B as Transform,x as groupD8};
//# sourceMappingURL=math.min.mjs.map
